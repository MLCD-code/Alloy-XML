<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-22 Fri 11:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Operator precedence test cases</title>
<meta name="author" content="CMSMcQ" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Operator precedence test cases</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgca1e5fd">1. The sample grammar</a></li>
<li><a href="#org7edd87e">2. A leveled grammar</a></li>
<li><a href="#org0608027">3. A discrepancy between the grammars</a></li>
<li><a href="#orge193abd">4. What does the operator precedence table mean in this case?</a></li>
<li><a href="#orgb5d2acb">5. An augmented leveled grammar</a></li>
<li><a href="#org7928849">6. An ambiguity</a></li>
<li><a href="#orge6c5c97">7. What now?</a></li>
<li><a href="#org6528470">8. Accepting ambiguity and choosing the correct tree</a>
<ul>
<li><a href="#orgd3055ae">8.1. The two trees</a></li>
<li><a href="#orgba32b9c">8.2. The parse-forest grammar</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This document describes some experiments with rendering
operator-precedence grammars into ixml.
</p>

<p>
The topic arose in connection with work on an ixml grammar for the
modeling language Alloy.  The language of Alloy models is defined
independently of any particular piece of software, but de facto the
tool most people will use to work with Alloy models is the parser
built in to the Alloy Analyzer.  Like a lot of people specifying
programming languages and the like, the Alloy developers give an
ambiguous definition for expressions, and rely on operator precedence
and associativity declarations to eliminate ambiguity.  I think that's
common for users of yacc and CUP and similar tools.
</p>

<p>
Now, if I understand things correctly, I think the usual thinking is
that operator precedence parsing makes the grammar more compact, but
does not extend the expressive power of the formalism &#x2013; which if true
would mean that given any ambiguous context-free grammar G
supplemented by operator precedence declarations that resolve
ambiguities, there must be a way to write a pure context-free grammar
to recognize the same language, L(<i>G</i>).  Actually, what I need is
something a bit more: I would like an <i>unambiguous</i> grammar that
recognizes <i>L(G)</i> and also <i>produces the same ASTs</i>.
</p>

<p>
I am beginning to think that there are cases where such a grammar is
beyond our grasp.  So for practical reasons, perhaps I could settle
for an ambiguous grammar which accepts <i>L(G)</i> and produces the
appropriate output trees with the help of Coffeepot's <code>--choose</code>
option.
</p>

<div id="outline-container-orgca1e5fd" class="outline-2">
<h2 id="orgca1e5fd"><span class="section-number-2">1.</span> The sample grammar</h2>
<div class="outline-text-2" id="text-1">
<p>
Consider a language with a left-associative binary infix operator BOP, a
right-associative unary prefix operator POP, and a non-associative unary
suffix operator SOP, with precedence BOP, SOP, POP (tightest-binding
first), and the following grammar:
</p>
<div class="org-src-container">
<pre class="src src-ixml">expression = s, expr, s.
expr = basic
     ; expr, s, BOP, s, expr
     ; POP, s, expr
     ; expr, s, SOP
     ; '(', s, expr, s, ')'.

{ Low-level definitions }
&lt;&lt;Basics&gt;&gt;
</pre>
</div>

<p>
Some nonterminals we are going to use several times, so we put them
in a separate block:
</p>
<div class="org-src-container">
<pre class="src src-ixml">basic = ['abcde'].
BOP = -'BOP'.
POP = -'POP'.
SOP = -'SOP'.
-s = -[#9;#A;#D;#20]*.
</pre>
</div>

<p>
First, let's consider some relatively unproblematic cases.
</p>

<p>
The input "<code>a</code>" should turn into suitable XML.
</p>
<div class="org-src-container">
<pre class="src src-sh" id="org57e8b4b">/usr/bin/java \
    -jar /home/sw/coffeepot-3.2.6/coffeepot-3.2.6.jar \
    --grammar grammars/BSP.ambiguous.ixml \
    -pp \
    "a"; echo
</pre>
</div>

<pre class="example">
&lt;expression&gt;
   &lt;expr&gt;
      &lt;basic&gt;a&lt;/basic&gt;
   &lt;/expr&gt;
&lt;/expression&gt;
</pre>


<p>
The input "<code>a BOP b</code>" should work, too.
</p>

<pre class="example" id="org1e49c63">
&lt;expression&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;basic&gt;b&lt;/basic&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;
</pre>

<p>
The input "<code>a BOP b BOP c</code>", on the other hand, will be ambiguous,
because the grammar says nothing about whether it's left or right
associative.
</p>

<pre class="example" id="org5036204">
&lt;ixml parses="2" totalParses="2"&gt;
&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;basic&gt;a&lt;/basic&gt;
         &lt;/expr&gt;
         &lt;BOP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;basic&gt;c&lt;/basic&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
         &lt;BOP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;c&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;/ixml&gt;

</pre>

<p>
And interactions between operators will also produce
ambiguity:
</p>

<pre class="example" id="orgc3e6462">
&lt;ixml parses="5" totalParses="5"&gt;
&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;POP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;a&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
         &lt;SOP/&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;POP/&gt;
            &lt;expr&gt;
               &lt;basic&gt;a&lt;/basic&gt;
            &lt;/expr&gt;
         &lt;/expr&gt;
         &lt;BOP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
      &lt;SOP/&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;POP/&gt;
         &lt;expr&gt;
            &lt;expr&gt;
               &lt;basic&gt;a&lt;/basic&gt;
            &lt;/expr&gt;
            &lt;BOP/&gt;
            &lt;expr&gt;
               &lt;basic&gt;b&lt;/basic&gt;
            &lt;/expr&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
      &lt;SOP/&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;POP/&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;expr&gt;
               &lt;basic&gt;a&lt;/basic&gt;
            &lt;/expr&gt;
            &lt;BOP/&gt;
            &lt;expr&gt;
               &lt;basic&gt;b&lt;/basic&gt;
            &lt;/expr&gt;
         &lt;/expr&gt;
         &lt;SOP/&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;POP/&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;basic&gt;a&lt;/basic&gt;
         &lt;/expr&gt;
         &lt;BOP/&gt;
         &lt;expr&gt;
            &lt;expr&gt;
               &lt;basic&gt;b&lt;/basic&gt;
            &lt;/expr&gt;
            &lt;SOP/&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;/ixml&gt;

</pre>

<p>
The five parse trees here can be summarized more compactly as labeled
trees:
</p>
<ul class="org-ul">
<li>BOP(POP(a), SOP(b))</li>
<li>SOP(BOP(POP(a), b))</li>
<li>SOP(POP(BOP(a, b)))</li>
<li>POP(SOP(BOP(a, b)))</li>
<li>POP(BOP(a, SOP(b)))</li>
</ul>
</div>
</div>


<div id="outline-container-org7edd87e" class="outline-2">
<h2 id="org7edd87e"><span class="section-number-2">2.</span> A leveled grammar</h2>
<div class="outline-text-2" id="text-2">
<p>
We can (or so thought I) describe the same language without operator
precedence rules by building them into the grammar in the style of
XPath: just split <i>expr</i> into different levels for each operator:
</p>

<div class="org-src-container">
<pre class="src src-ixml">expr = expr-1.
expr-1 = expr-2; POP, expr-1.
expr-2 = expr-3; expr-3, SOP.
expr-3 = expr-4; expr-3, BOP, expr-4.
expr-4 = basic; '(', s, expr, s, ')'.
</pre>
</div>

<p>
Or &#x2013; this is ixml, let's give ourselves useful names for the elements
we are going to get:
</p>

<div class="org-src-container">
<pre class="src src-ixml">expression = s, expr, s.
     -expr = expr-1.
   -expr-1 = pop-expr; expr-2.
  pop-expr = POP, s, expr-1.
   -expr-2 = sop-expr; expr-3.
  sop-expr = expr-3, s, SOP.
   -expr-3 = bop-expr; expr-4.
  bop-expr = expr-3, s, BOP, s, expr-4.
   -expr-4 = basic; '(', s, expr, s, ')'.

  &lt;&lt;Basics&gt;&gt;
</pre>
</div>

<p>
Now it's clear how "POP a BOP b SOP" is parsed: as (POP ((a BOP b)
SOP)).  Hurrah.
</p>

<pre class="example" id="org1875258">
&lt;expression&gt;
   &lt;pop-expr&gt;
      &lt;POP/&gt;
      &lt;sop-expr&gt;
         &lt;bop-expr&gt;
            &lt;basic&gt;a&lt;/basic&gt;
            &lt;BOP/&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/bop-expr&gt;
         &lt;SOP/&gt;
      &lt;/sop-expr&gt;
   &lt;/pop-expr&gt;
&lt;/expression&gt;
</pre>

<p>
Since we now have names for <i>pop-expr</i>, <i>bop-expr</i> and <i>sop-expr</i>, the
rules for <i>BOP</i> etc. could be hidden, but I won't bother with that.
</p>

<p>
In the leveled grammar, BOP is clearly left-associative:
</p>
<pre class="example" id="orgda0c507">
&lt;expression&gt;
   &lt;bop-expr&gt;
      &lt;bop-expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
         &lt;BOP/&gt;
         &lt;basic&gt;b&lt;/basic&gt;
      &lt;/bop-expr&gt;
      &lt;BOP/&gt;
      &lt;basic&gt;c&lt;/basic&gt;
   &lt;/bop-expr&gt;
&lt;/expression&gt;
</pre>
</div>
</div>


<div id="outline-container-org0608027" class="outline-2">
<h2 id="org0608027"><span class="section-number-2">3.</span> A discrepancy between the grammars</h2>
<div class="outline-text-2" id="text-3">
<p>
There is, however, a catch.  Consider the input:
</p>

<div class="org-src-container">
<pre class="src src-bop">a BOP b BOP POP c
</pre>
</div>

<p>
This is constructed to parallel a real-world example in Alloy which
the author had clearly intended, and the Alloy parser clearly parsed,
as equivalent to
</p>

<div class="org-src-container">
<pre class="src src-bop">(a BOP b) BOP (POP c)
</pre>
</div>

<p>
But the leveled grammar simply doesn't accept the input; it requires
parentheses around (POP c) because the right-hand operand of BOP
contains only an <i>expr-4</i>, and <code>POP c</code> is an <i>expr-1</i>.
</p>

<pre class="example">
&lt;fail xmlns:ixml='http://invisiblexml.org/NS' ixml:state='failed'&gt;
   &lt;line&gt;1&lt;/line&gt;
   &lt;column&gt;14&lt;/column&gt;
   &lt;pos&gt;13&lt;/pos&gt;
   &lt;unexpected&gt;P&lt;/unexpected&gt;
   &lt;permitted&gt;'(', [#9; #A; #D; ' '], [#9; #A; #D; ' '], ['abcde']&lt;/permitted&gt;
&lt;/fail&gt;
</pre>


<p>
Of course, it parses without trouble if we wrap the pop-expression in
parentheses as "<code>a BOP b BOP (POP c)</code>".
</p>
<pre class="example" id="org9cabaf0">
&lt;expression&gt;
   &lt;bop-expr&gt;
      &lt;bop-expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
         &lt;BOP/&gt;
         &lt;basic&gt;b&lt;/basic&gt;
      &lt;/bop-expr&gt;
      &lt;BOP/&gt;(
      &lt;pop-expr&gt;
         &lt;POP/&gt;
         &lt;basic&gt;c&lt;/basic&gt;
      &lt;/pop-expr&gt;)&lt;/bop-expr&gt;
&lt;/expression&gt;
</pre>

<p>
But in that case, I have not defined quite the same language as the
operator-precedence grammar: I'm requiring parens in a case where it
does not.
</p>
</div>
</div>

<div id="outline-container-orge193abd" class="outline-2">
<h2 id="orge193abd"><span class="section-number-2">4.</span> What does the operator precedence table mean in this case?</h2>
<div class="outline-text-2" id="text-4">
<p>
I have not found any very clear or persuasive discussion of the issue,
but how to deal with or understand the interaction of unary operators
and binary operators and their relative precedences does occasionally
get discussed on the web, and the closest thing I've found to a coherent
position is the view that operator precedence and associativity
declarations only matter when you have to appeal to them to resolve an
ambiguity.  When there is only one possible parse tree, they don't
matter.  Imagine putting parens in, tightest bindings first.  BOP
associates left, so we do the first BOP first:
</p>
<div class="org-src-container">
<pre class="src src-txt">(a BOP b) BOP POP c
</pre>
</div>

<p>
For the second BOP operator, the left operand clearly must be the first
bop-expressoin, and the right operand is also obvious:  it
can't be just "<code>POP</code>", and it cannot be just "<code>c</code>" (what would
we then do with the POP?), so it has to be "<code>POP c</code>".  So:
</p>
<div class="org-src-container">
<pre class="src src-txt">((a BOP b) BOP (POP c))
</pre>
</div>

<p>
And just to confirm that there is no other way to interpret this
input, let's try parsing it against the original ambiguous grammar.
We get (<i>drum roll, please &#x2026; !</i>) two parses, because the original
grammar does not specify left- or right-associativity for BOP.  Oops.
</p>

<pre class="example" id="orgaaf9920">
&lt;ixml parses="2" totalParses="2"&gt;
&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;basic&gt;a&lt;/basic&gt;
         &lt;/expr&gt;
         &lt;BOP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;POP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;c&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
         &lt;BOP/&gt;
         &lt;expr&gt;
            &lt;POP/&gt;
            &lt;expr&gt;
               &lt;basic&gt;c&lt;/basic&gt;
            &lt;/expr&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;&lt;/ixml&gt;

</pre>

<p>
If we simplify the input to "<code>a BOP POP b</code>", the input is unambiguous
against the original grammar.
</p>

<pre class="example" id="org112dd12">
&lt;expression&gt;
   &lt;expr&gt;
      &lt;expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
      &lt;/expr&gt;
      &lt;BOP/&gt;
      &lt;expr&gt;
         &lt;POP/&gt;
         &lt;expr&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/expr&gt;
      &lt;/expr&gt;
   &lt;/expr&gt;
&lt;/expression&gt;
</pre>

<p>
That confirms the intuition that a parser which consults the
precedence table only to resolve ambiguities can plausibly accept a
POP expression as the right-hand operand to a BOP expression, even if
the precedence table says that BOP binds tighter than POP.  Against
the original grammar, this sentence is not ambiguous.
</p>

<p>
It should be noted, on the other hand, that the operator-precedence
parser in Prolog does <i>not</i> accept this input, given appropriate
declarations of the operators:
</p>
<pre class="example" id="org98a54ae">
?- op(610, yfx, bop), op(620, yf, sop), op(630, fy, pop).
true.

?- write_canonical( a bop b bop c ).
bop(bop(a,b),c)
true.

?- write_canonical( pop a bop b sop ).
pop(sop(bop(a,b)))
true.

?- write_canonical( a bop pop b ).
ERROR: Syntax error: Operator priority clash
ERROR: write_canonical( a bo
ERROR: ** here **
ERROR: p pop b ) . 
?- 
</pre>

<p>
That is, the Prolog parser's implementation of operator-precedence
parsing makes it a rule that in parsing unparenthesized input, an
operator <i>P</i> can have an operator <i>Q</i> as an operand if and only if the
precedence value declared for <i>P</i> is greater than or equal to the
precedence value declared for <i>Q</i>.  (If the operand in question is
declared with <i>x</i>, the operand's value must be strictly less than that
of the parent; if it's declared <i>y</i>, the operand's value can equal
that of the parent.)
</p>

<p>
That interpretation of the operator precedence table is the one
implicit in the leveled grammar.
</p>
</div>
</div>

<div id="outline-container-orgb5d2acb" class="outline-2">
<h2 id="orgb5d2acb"><span class="section-number-2">5.</span> An augmented leveled grammar</h2>
<div class="outline-text-2" id="text-5">
<p>
Perhaps there is a solution.
</p>

<p>
If any expression using a prefix-operator can occur on the right-hand
side of a binary operator, then perhaps we should just say so.  Add
pop-expr to the rule for the right-hand operand of BOP.  And similarly
add sop-expr to the rule for its left-hand operand.  (N.B. In more
complicated cases, you only do this for prefix and suffix operators of
weaker binding power; otherwise, it introduces an unnecessary and
pointless ambiguity.)
</p>

<div class="org-src-container">
<pre class="src src-ixml">expression = s, expr, s.
     -expr = expr-1.
   -expr-1 = pop-expr; expr-2.
  pop-expr = POP, s, expr-1.
   -expr-2 = sop-expr; expr-3.
  sop-expr = expr-3, s, SOP.
   -expr-3 = bop-expr; expr-4.
  bop-expr = (expr-3; sop-expr), 
             s, BOP, s, 
             (expr-4; pop-expr).
   -expr-4 = basic; '(', s, expr, s, ')'.

  &lt;&lt;Basics&gt;&gt;
</pre>
</div>

<p>
Call this grammar the 'leveled-plus' approach: a leveled grammar plus
special rules for the left and right operands of binary operators, to
allow them to handle suitable prefix and suffix operators as operands.
</p>

<p>
Now the grammar accepts the input "<code>a BOP b BOP POP c</code>" and gives it
the desired structure.
</p>

<pre class="example" id="orgbddd357">
&lt;expression&gt;
   &lt;bop-expr&gt;
      &lt;bop-expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
         &lt;BOP/&gt;
         &lt;basic&gt;b&lt;/basic&gt;
      &lt;/bop-expr&gt;
      &lt;BOP/&gt;
      &lt;pop-expr&gt;
         &lt;POP/&gt;
         &lt;basic&gt;c&lt;/basic&gt;
      &lt;/pop-expr&gt;
   &lt;/bop-expr&gt;
&lt;/expression&gt;
</pre>

<p>
Tada!
</p>
</div>
</div>

<div id="outline-container-org7928849" class="outline-2">
<h2 id="org7928849"><span class="section-number-2">6.</span> An ambiguity</h2>
<div class="outline-text-2" id="text-6">
<p>
Unfortunately, there is another catch.
</p>

<p>
Actually, the real-world example I mentioned before is a little more
complicated:  in reality the example had the equivalent of 
</p>
<div class="org-src-container">
<pre class="src src-txt">a BOP b BOP POP c BOP d
</pre>
</div>
<p>
with the same structure as
</p>
<div class="org-src-container">
<pre class="src src-txt">(a BOP b) BOP (POP (c BOP d))
</pre>
</div>

<p>
When I ran the input against my leveled-plus grammar, what I got was a
notice that the input was ambiguous.  Because the leveled-plus grammar
allows two parses for the input:  the desired one shown above, and
</p>
<div class="org-src-container">
<pre class="src src-txt">((a BOP b) BOP (POP c)) BOP d
</pre>
</div>

<p>
In the real-world Alloy model, the clear intent was that the POP
operator govern the binary operator to its right. That's what the
Alloy parser does, and that's what yacc-style parsers do with such
input, given the original grammar and precedence table.  But in the
level-plus grammar,
</p>

<pre class="example" id="orge68c61a">
&lt;ixml parses="2" totalParses="2"&gt;
&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;bop-expr&gt;
      &lt;bop-expr&gt;
         &lt;bop-expr&gt;
            &lt;basic&gt;a&lt;/basic&gt;
            &lt;BOP/&gt;
            &lt;basic&gt;b&lt;/basic&gt;
         &lt;/bop-expr&gt;
         &lt;BOP/&gt;
         &lt;pop-expr&gt;
            &lt;POP/&gt;
            &lt;basic&gt;c&lt;/basic&gt;
         &lt;/pop-expr&gt;
      &lt;/bop-expr&gt;
      &lt;BOP/&gt;
      &lt;basic&gt;d&lt;/basic&gt;
   &lt;/bop-expr&gt;
&lt;/expression&gt;&lt;expression xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'&gt;
   &lt;bop-expr&gt;
      &lt;bop-expr&gt;
         &lt;basic&gt;a&lt;/basic&gt;
         &lt;BOP/&gt;
         &lt;basic&gt;b&lt;/basic&gt;
      &lt;/bop-expr&gt;
      &lt;BOP/&gt;
      &lt;pop-expr&gt;
         &lt;POP/&gt;
         &lt;bop-expr&gt;
            &lt;basic&gt;c&lt;/basic&gt;
            &lt;BOP/&gt;
            &lt;basic&gt;d&lt;/basic&gt;
         &lt;/bop-expr&gt;
      &lt;/pop-expr&gt;
   &lt;/bop-expr&gt;
&lt;/expression&gt;&lt;/ixml&gt;
</pre>
</div>
</div>



<div id="outline-container-orge6c5c97" class="outline-2">
<h2 id="orge6c5c97"><span class="section-number-2">7.</span> What now?</h2>
<div class="outline-text-2" id="text-7">
<p>
I can think of a couple paths forward, neither of them very appealing.
</p>

<ul class="org-ul">
<li>Go back to the leveled grammar; require some parentheses.  It's not
the worst thing in the world.</li>

<li><p>
Add a post-processor to look for an detect the structure
</p>

<ul class="org-ul">
<li>bop-expr
<ul class="org-ul">
<li>bop-expr
<ul class="org-ul">
<li>whatever 1</li>
<li>pop-expr
<ul class="org-ul">
<li>whatever 2</li>
</ul></li>
</ul></li>
<li>whatever 3</li>
</ul></li>
</ul>

<p>
and rewrite it appropriately as
</p>

<ul class="org-ul">
<li>bop-expr
<ul class="org-ul">
<li>whatever 1</li>
<li>pop-expr
<ul class="org-ul">
<li>bop-expr
<ul class="org-ul">
<li>whatever 2</li>
<li>whatever 3</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Hmm.  To make this work, I have to make the parse tree retain parens,
so I can distinguish between "a BOP b BOP POP c BOP d" and "(a BOP b
BOP POP c) BOP d" and not screw up the latter.
</p></li>
</ul>

<p>
Is there any other way forward?
</p>

<p>
Now that I re-read their section on operator-precedence parsing, I see
that Grune and Jacob give a hint that maybe the usual thinking is not
quite correct, and that operator-precedence parsers may in fact affect
expressive power, at least in the sense of not necessarily producing the
same trees.  First, they make a point that OP parsing does not produce
full trees, only 'skeleton trees' without full labeling.  And second
they say "In some sense [operator precedence] is even stronger than the
more famous LR techniques:  operator precedence can easily handle
ambiguous grammars, as long as the ambiguity remains restricted to the
labeling of the tree. &#x2026; It achieves its partial superiority over LR by
not fulfilling the complete task of parsing:  getting a completely
labeled parse tree."
</p>

<p>
Of course, in this case there is a structural difference between the two
parses for "a BOP b BOP POP c BOP d", not just a labeling difference.
And I am not sure I will ever really understand what G/J say about OP
parsing unless I try to implement it, because my eyes just glaze right
over.
</p>
</div>
</div>

<div id="outline-container-org6528470" class="outline-2">
<h2 id="org6528470"><span class="section-number-2">8.</span> Accepting ambiguity and choosing the correct tree</h2>
<div class="outline-text-2" id="text-8">
<p>
Since writing the above, it has been called (again) to my attention
that Coffeepot has a way to express a preference in cases of
ambiguity.  Let's try it.  And more generally, let's consider the
question: what kind of provisions for choosing among alternative
parses would suffice to allow the correct choice to be made here? That
is, what kinds of pragmas or extensions would an ixml processor need
to offer, to allow us to tell it a reliable rule for choosing among
the trees?
</p>

<p>
Before we can attempt to answer that, though, we should try to answer
the logically prior question: what exactly <i>is</i> the rule here?  My
best efforts at describing the two interpretations of
operator-precedence tables can perhaps be summarized as follows.  I'll
give them short names: Rule P (for the Prolog rule), Rule Y (for the
yacc / CUP / LR parser rule).
</p>

<p>
Some basic assumptions are true in both cases:
</p>

<ul class="org-ul">
<li>Every operator has a precedence value; following Prolog, we will
assign low values to tight-binding operators, high values to
loose-binding operators.</li>

<li>Basic operator-free expressions and parenthesized expressions
are taken to have precedence value 0.</li>

<li>Every operator is declared non-associative, left-associative, or
right-associative.</li>

<li>No production rule has a right-hand side containing more than one
operator, so no node in the parse tree has more than one operator as
a child.  Production rules (or equivalently: right-hand sides) are
assigned the precedence value of their operator if any.</li>

<li>We imagine an abstract syntax tree in which nodes immediately
dominating an operator will be annotated with that operator, so we
can talk about a BOP-node or a POP-node, or more generally an
op-node with a given precedence value.</li>

<li>Every unary op-node has one child identified as its operand; every
binary op-node has identifiable left and right operands.</li>
</ul>

<p>
We can now formulate the two rules:
</p>

<ul class="org-ul">
<li><p>
<b>Rule P:</b> Given unparenthesized input, every operand op-node has a
precedence value less than or equal to that of its parent.  For the
operand of a non-associative operator, the left operand of a
right-associative operator, or the right operand of a
left-associative operator, the operand's precedence value is strictly
less than that of its parent.
</p>

<p>
In the case of "<code>a BOP b BOP POP c BOP d</code>", this rule forbids any
tree in which a BOP-node has a POP-node as a child.
</p>

<p>
This is (unless I am mistaken) the rule implemented by the leveled
grammar.
</p></li>

<li><p>
<b>Rule Y:</b> Whenever there is a shift-reduce conflict between shifting
for an operator with precedence value <i>s</i> and reducing for a rule
with precedence value <i>r</i>, then
</p>

<ul class="org-ul">
<li>if <i>s</i> &lt; <i>r</i>, the shift is chosen; otherwise</li>
<li>if <i>r</i> &lt; <i>s</i>, the reduction is chosen; otherwise</li>
<li>the ambiguity cannot be resolved.</li>
</ul>

<p>
In the case of "<code>a BOP b BOP POP c BOP d</code>", this rule specifies that
given the choice between reducing the input string "<code>POP c</code>" by the
rule for POP expressions and shifting the third BOP token onto the
stack, the parser will choose the shift.  The reduction choice would
in this case ultimately make the POP an operand of the preceding BOP
and a descendant of the following BOP.  The shift choice will lead
ultimately to a reduction against the rule for BOP expressions and
then against the rule for POP expressions, and thus will have the
effect of parsing the BOP as a child or descendant of the POP).
</p>

<p>
This is the rule we need to follow if we wish to produce the same
abstract syntax trees as the Alloy Analyzer.
</p></li>
</ul>

<p>
It will not have escapted the reader's attention that Rule Y is
thoroughly procedural and relies not on properties of the grammar
rules or the possible parse trees but on situations that arise when
using one particular parsing algorithm.  It would be nice to find some
description of the rule that relies only on a description of the
grammar, or of the parse trees.
</p>

<p>
The grammar(s) are given above.  It may help to spend some time
looking at the trees.
</p>
</div>

<div id="outline-container-orgd3055ae" class="outline-3">
<h3 id="orgd3055ae"><span class="section-number-3">8.1.</span> The two trees</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Ignoring whitespace, the two trees for "<code>a BOP b BOP POP c BOP d</code>" are
shown in this diagram: one red, one navy-blue.  The material in black
is common to both trees.
</p>


<div id="orgf0f6158" class="figure">
<p><img src="images/a.bop.b.bop.pop.c.bop.d.dot.svg" alt="a.bop.b.bop.pop.c.bop.d.dot.svg" class="org-svg" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgba32b9c" class="outline-3">
<h3 id="orgba32b9c"><span class="section-number-3">8.2.</span> The parse-forest grammar</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Another way to look at the trees produced for an ambiguous sentence is
the parse forest grammar.  In this case, it's in <a href="grammars/pfg.ixml">a separate file</a>.
</p>

<p>
With luck, maybe I can also persuade org-mode to show it here in-line.
(Hmm.  No luck yet.  I'll come back to this.)
</p>

<p>
<a href="grammars/pfg.ixml">grammars/pfg.ixml</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 21 March 2024</p>
<p class="author">Author: CMSMcQ</p>
<p class="date">Created: 2024-03-22 Fri 11:36</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
