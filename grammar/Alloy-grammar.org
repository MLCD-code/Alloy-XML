:PROPERTIES:
:ID:       Alloy
:END:
#+title: Alloy grammar in invisible XML
#+date: 2024-02-23/2024-03/13
#+author: Michael Sperberg-McQueen
#+startup: showall
#+tangle: yes

This document gives a grammar for Alloy in invisible XML (ixml) form,
embedded in expository prose.

The reader is assumed to have some familiarity with Alloy and
context-free grammars.  Details of ixml syntax will not be explained.

*** Revision history

Revisions:

- 2024-03-26 : CMSMcQ : suppress a number of literals and nonterminals
- 2024-03-26 : CMSMcQ : parse MLCD models, find and fix some errors
- 2024-03-26 : CMSMcQ : resolve or accept all failures to parse
                        examples that ship with Alloy
- 2024-03-15 : CMSMcQ : find and fix some bugs; change some s to S.
- 2024-03-14 : CMSMcQ : better names (without reserved words)
- 2024-03-10/13 : CMSMcQ : pushing through
- 2024-03-10 : CMSMcQ : split expr into expr01 .. expr19
- 2024-03-10 : CMSMcQ : I think whitespace is dealt with.
- 2024-02-23 : CMSMcQ : move to an org file (as illustrated by NDTW).
- 2024-02-23 : CMSMcQ : resume work.
- 2021-05-06 : CMSMcQ : made ixml grammar.  Not finished.

*** To do
**** DONE Clean up /name/ handling (again) - issue #5
CLOSED: [2024-03-26 Tue 15:28]
https://github.com/MLCD-code/Alloy-XML/issues/5
**** TODO Check grammar against quick guide to Alloy 4
http://alloytools.org/quickguide/
- "~seq~" as reserved word
- "~private~" as reserved word
- meta-facility
**** Support macros as described in quick guide?
http://alloytools.org/quickguide/macro.html
**** Support grammar of 6.0?
http://alloytools.org/spec.html

* Preliminary notes
:PROPERTIES:
:CUSTOM_ID: notes
:END:

The grammar started as a fairly literal transcription from the
Alloy 4 grammar on the Alloy Tools web site, but in its current
form it is a manually constructed mixture of three grammars:

- the grammar in Appendix B of Daniel Jackson's /Software abstractions/ 2d edition.
- the grammar at http://alloytools.org/download/alloy4-grammar.txt.
- the grammar at https://github.com/AlloyTools/org.alloytools.alloy/blob/master/org.alloytools.alloy.core/parser/Alloy.cup.
  
In what follows, these may be referred to respectively as /J/, /G/,
and /C/ (for /Jackson/, /grammar/, and /CUP/ grammar).  /C/ has been
consulted only for clarification of specific points; in particular,
the grammar here does not include the new keywords and constructions
which are part of the extension to temporal logic in Alloy 6.

*Goal(s):* The obvious goal for an ixml grammar of Alloy is to make a
grammar that comes as close as feasible to accepting the same language
as the Alloy 6.0 Analyzer.  A second less ambitious goal is to match
an earlier version of the language (4.0, or 5.1).  But the core goal
is to handle the subset of Alloy used in the models made by the MLCD
project; anything else is supererogatory.  We would derive a certain
amount of satisfaction from supporting the entire 6.0 language, but it
is not part of the minimum required to declare victory.

*Differences from /J/ and /G/:* In the grammar given here, I have
- rewritten the rule for expressions so that operator precedence
  follows automatically from the structure of the grammar, rather
  than being declared separately;
  
- renamed some nonterminals in an attempt to give them more
  descriptive names (which affects the readability of the grammar, but
  even more so the readability of the XML produced);

- split a number of nonterminals in order to give distinct names to
  variants of the production which are notionally distinct; and

- introduced some new nonterminals so as to give some things more
  informative labels (e.g. the /module-arguments/ and /alias/ in an
  /import/).

*Relations and formulas:* Semantically, Alloy distinguishes between
relation-valued and boolean-valued expressions (aka formulas or
constraints), but the distinction is not made in the grammar given
here. But it may be observed that the logical operators bind less
tightly than the relational operators, so at a first approximation we
can say that /expr01/ through /expr08/ (or at least /expr07/) are
boolean-valued, and /expr09/ through /expr19/ are relation-valued.

*Whitespace handling:* For the most part, we follow the basic
principle that no nonterminal except the outermost one starts or ends
with whitespace.  Some exceptions are made for common separators
(/slash/, /comma/, /plus/).

In this grammar, /s/ denotes optional whitespace, /S/ required
whitespace.  I've tried to use /S/ whenever two alphabetic tokens can
be adjacent, because otherwise the parser will insert nonsensical
token boundaries (like parsing "~none~" as the keyword "~no~" followed
by the name "~ne~").  This has the unfortunate side effect of making
the grammar reject some modules which the Alloy parser would accept.

*Unit rules:* A unit rule in the grammar produces a parse-tree node
with a single child.  In the XML produced by an ixml processor, this
can lead to very deep trees which some readers find less easy to
navigate than shallower trees would be.  In the XML form of the
abstract syntax tree, I have where possible tried to eliminate either
the child node or the parent node; sometimes this has entailed
restructuring a production.

*Differences in the language accepted:* In consequence of some of the
grammatical differences given above, the language accepted by this
grammar deviates from that accepted by the Alloy Analyzer in some ways.
At the time this was written, the known deviations were these:
- Whitespace will be required in some locations where the Analyzer
  does not require it.
- Parentheses will be required around /let/-expressions and quantified
  formulas when they appear as operands of any other operator; the
  Analyzer does not always require parentheses in these cases.

* Top level:  modules
:PROPERTIES:
:CUSTOM_ID: toplevel
:END:

An Alloy module consists of a series of zero or more paragraphs,
optionally preceded by a module declaration and zero or more import
statements.

#+BEGIN_SRC ixml :tangle yes
Alloy-module: s, (module-decl, s)?, (import++s, s)?, (paragraph++s, s)?.
#+END_SRC

For comparison, /J/ has:
#+BEGIN_SRC Jebnf :tangle no
alloyModule ::= [moduleDecl] import* paragraph*
#+END_SRC

/G/ has:
#+BEGIN_SRC ebnf4 :tangle no
specification ::= [module] open* paragraph*
#+END_SRC

** Module declaration

A module declaration gives the module a name (optionally
qualified by a prepended path) and may specify a series of
signature parameters given in square brackets.

#+BEGIN_SRC ixml :tangle yes
-module-decl: -"module", s, module-name, (s, parameters)?.
module-name: OQName.
parameters:  -"[", s, ((EXACTLY, s)?, name)++comma, s, -"]".
#+END_SRC

In /J/, the signature parameters are just a sequence of
comma-separated names:
#+BEGIN_SRC Jebnf :tangle no
moduleDecl ::= "module" qualName  [ "[" name,+ "]" ]
#+END_SRC
But the /ordering/ utility model uses "exactly" as a modifier, which
appears to be a later elaboration of the grammar.

In /G/, by contrast, the comma-separated parameter sequence begins
with one name, followed by zero or more numbers.
#+BEGIN_SRC ebnf4 :tangle no
module ::= "module" name  [ "["  ["exactly"] name  ("," ["exactly"] num)*    "]" ]
#+END_SRC

*Q* What does "exactly" do here? *A* It specifies that the
signature bound to the parameter in the external module
should have exactly the same cardinality as the signature
named in the argument.

/J/ and /G/ differ in their treatment of names, in a way that needs to
be mentioned.  /J/ distinguishes
- /name/, a single-token lexical symbol, and 
- /qualName/, a sequence of one or more names separated with slashes,
  optionally preceded by ~this/~.

For its (slightly different) versions of these two, /G/ uses the
nonterminals /ID/ and /name/, respectively.  Also, /G/ often uses the
nonterminal /ref/ where /J/ uses /name/: in /G/, /ref/ is a name or
one of a small number of predefined identifiers (~univ~, ~Int~,
~seq/Int~).

Here, the nonterminal /name/ is used for a single token, and
/qual-name/ is reserved for compound (qualified) names with non-empty
paths.  In context where either is possible (/J/'s /qualName/ or /G/'s
/name/ or /ref/), the nonterminal /OQName/ ('optionally qualified
name') is used.

** Imports
Import statements identify modules to be imported.  If the module
being imported is parameterized, each parameter must be given a value
consisting of the qualified name of a signature.  The module can also
be given an alias.

#+BEGIN_SRC ixml :tangle yes
import: (private, S)?, -"open", s, OQName,
        (s, module-arguments)?,
        (s, -"as", s, alias)?.
module-arguments: -"[", s, ref++comma, s, -"]".
alias: -name.
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
import ::= "open"  qualName  [ "[" qualName,+ "]" ]  [ "as" name ]
#+END_SRC


/G/:
#+BEGIN_SRC ebnf4 :tangle no
open ::= ["private"]  "open"  name  [ "[" ref,+ "]" ]  [ "as" name ]
#+END_SRC

** Kinds of paragraphs
#+BEGIN_SRC ixml :tangle yes
paragraph: fact-decl | assert-decl | fun-decl | pred-decl 
         | cmd-decl | enum-decl | sig-decl.
#+END_SRC

/J/ lacks /enumDecl/:
#+BEGIN_SRC Jebnf :tangle no
paragraph ::= sigDecl | factDecl | predDecl | funDecl | assertDecl | cmdDecl 
#+END_SRC

/G/ omits /factDecl/ and adds /enumDecl/.
#+BEGIN_SRC ebnf4 :tangle no
paragraph ::= factDecl | assertDecl | funDecl | cmdDecl | enumDecl | sigDecl
#+END_SRC

* Signatures
:PROPERTIES:
:CUSTOM_ID: signatures
:END:

A signature declares a set of atoms, specifies some relations in which
they participate (as the left-most member), and may optionally impose
constraints on them.

#+BEGIN_SRC ixml :tangle yes
sig-decl: (private, S)?, (abstract, S)?, (@mult, S)?, 
          -"sig", S, name++comma, S,
          (sig-ext, s)?,
          sig-body, 
          (s, sig-constraints)?.
sig-ext: extends; subset-of.
extends: -"extends", S, ref.
subset-of: -"in", S, ref++plus.
sig-body: -"{", s, (decl++comma, s)?, -"}".
sig-constraints: -block.
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
sigDecl ::= ["abstract"] [mult] "sig" name,+ [sigExt] "{" decl,* "}" [block]
sigExt ::= "extends" qualName | "in" qualName ["+" qualName]*
#+END_SRC

/G/ adds a ~private~ keyword (and allows repeated keywords):
#+BEGIN_SRC ebnf4 :tangle no
sigDecl ::= sigQual* "sig" name,+ [sigExt] "{" decl,* "}" [block]
sigQual ::= "abstract" | "lone" | "one" | "some" | "private"
sigExt ::= "extends" ref
sigExt ::= "in" ref ["+" ref]*
#+END_SRC

* Functions and predicates
#+BEGIN_SRC ixml :tangle yes
fun-decl: (private, S)?, 
          -"fun", S, (ref, -".")?, name, s, (args, s)?, -":", s, 
          function-bounds, s, block.
@function-bounds > bounds: expr.
pred-decl: (private, S)?, 
           -"pred", S, (ref, -".")?, name, s, (args, s)?, block.
args:  -"(", s, decl**comma, s, -")"
    |  -"[", s, decl**comma, s, -"]".
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
funDecl ::= "fun" [qualName "."] name [paraDecls] ":" expr "{" expr "}"
predDecl ::= "pred" [qualName "."] name [paraDecls] block
paraDecls ::= "(" decl,* ")" | "[" decl,* "]"
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
funDecl ::= ["private"] "fun" [ref "."] name "(" decl,* ")" ":" expr block
funDecl ::= ["private"] "fun" [ref "."] name "[" decl,* "]" ":" expr block
funDecl ::= ["private"] "fun" [ref "."] name                ":" expr block

funDecl ::= ["private"] "pred" [ref "."] name "(" decl,* ")" block
funDecl ::= ["private"] "pred" [ref "."] name "[" decl,* "]" block
funDecl ::= ["private"] "pred" [ref "."] name                block
#+END_SRC

* Facts and assertions
Facts and assertions are statements about the universe.
Assertions may or may not be true; facts are true by fiat.
#+BEGIN_SRC ixml :tangle yes
fact-decl: -"fact", S, (name, s)?, block.
assert-decl: -"assert", S, (name, s)?, block.
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
factDecl ::= "fact" [name] block
assertDecl ::= "assert" [name] block
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
factDecl ::= "fact" [name] block
assertDecl ::= "assert" [name] block
#+END_SRC

* Commands
Commands are instructions to the Alloy Analyser to check certain
states of affairs within instances with a given maximum size (scope):
seek instances of a predicate, seek counter-examples to an assertion.

#+BEGIN_SRC ixml :tangle yes
cmd-decl: (@name, s, -":", s)?, @verb, S, (name|block), (S, scope)?.
verb: "run"|"check".
scope: expectation
       | typescopes.
typescopes: -"for", S, numbers, (S, expectation)?.
-numbers: number, (s, exceptions)?
       | typescope++comma.
expectation:  -"expect", s, ("0" | "1").
typescope: exact-scope; max-scope.
exact-scope: -EXACTLY, s, -max-scope.
max-scope: number, s, (OQName|"int"|"Int"|"seq").
exceptions: -"but", s, typescope++comma.
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
cmdDecl ::= [name ":"] ["run"|"check"] [qualName|block] [scope]
scope ::= "for" number ["but" typescope,+] | "for" typescope,+
typescope ::= ["exactly"] number qualName
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
cmdDecl ::= [name ":"] ("run"|"check") (name|block) scope
scope ::= "for" number                   ["expect" (0|1)]
scope ::= "for" number "but" typescope,+ ["expect" (0|1)]
scope ::= "for"              typescope,+ ["expect" (0|1)]
scope ::=                                ["expect" (0|1)]
typescope ::= ["exactly"] number [name|"int"|"seq"]
#+END_SRC
/G/'s definition of /typescope/ introduces an ambiguity;
I'm going to go with /J/, which requires an identifier of
some kind.
* Common constructs
** Declarations

Declarations are used in many places, so I've given them their
own section here rather than putting them with just one of
their possible contexts.

#+BEGIN_SRC ixml :tangle yes
decl: (private, s)?, (disj, S)?, variable++comma, s, -":", s, bounds.
disj: -"disj".
variable: -name.
bounds: (disj, S)?, expr.
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
decl ::= ["disj"] name,+ ":" ["disj"] expr
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
decl ::= ["private"] ["disj"] name,+ ":" ["disj"] expr
#+END_SRC

** Expressions
:PROPERTIES:
:CUSTOM_ID: expressions
:END:

Like many grammars involving multiple operators, both /J/ and /G/ use
a single highly ambiguous production rule for expressions (/expr/),
and provide an operator precedence table to clarify which parse trees
should be accepted and which should be discarded.  See [[#ops][section on
Operators]] below.

This is the definition of /expr/ in /J/:

#+BEGIN_SRC Jebnf :tangle no
expr ::= const 
   | qualName 
   | "@" name 
   | "this"
   | unOp expr 
   | expr binOp expr 
   | expr arrowOp expr
   | expr "[" expr,* "]"
   | expr ["!"|"not"] compareOp expr
   | expr ("=>"|"implies") expr "else" expr
   | "let" letDecl,+ blockOrBar
   | quant    decl,+ blockOrBar
   | "{" decl,+ blockOrBar "}"
   | "(" expr ")" 
   | block
#+END_SRC

/G/ is largely the same but differs ih some details:
- It inlines /const/.
- It merges ~qualName | "@" name~.
- It does not single out ~this~, treating it instead as a /name/.
- It adds ~Int~ and ~seq/Int~.

#+BEGIN_SRC ebnf
expr ::= "let" letDecl,+ blockOrBar
       | quant decl,+    blockOrBar
       | unOp expr
       | expr binOp   expr
       | expr arrowOp expr
       | expr ["!"|"not"] compareOp expr
       | expr ("=>"|"implies") expr "else" expr
       | expr "[" expr,* "]"
       |     number
       | "-" number
       | "none"
       | "iden"
       | "univ"
       | "Int"
       | "seq/Int"
       | "(" expr ")"
       | ["@"] name
       | block
       | "{" decl,+ blockOrBar "}"
#+END_SRC

Because ixml makes no use of precedence tables, we need to re-express
operator precedence in the structure of the grammar.  We will do this
by factoring /expr/ into several flavors, which we name /expr01/,
/expr02/, etc., each defining expressions involving operators at one
precedence level.

In their pure form, the levels look something like this:

- 1: let-expr:  "let", s, let-decl++comma, s, block-or-bar.
- 1: all-ex01:  "all",  s, decl++comma, s, block-or-bar.
  /(And similarly for ~no~, ~some~, ~lone~, ~one~, ~sum~.)/
- 2: disjunction:  expr02, s, ("||"; "or"), s, expr03.
- 3: bi-implication:  expr03, s, ("<=>"; "iff"), s, expr04.
- 4: if-then:  expr05, s, ("=>"; "implies"), s, expr04.
- 4 bis: if-then-else: expr05, s, ("=>"; "implies"), s, expr04-bis, s, "else", s, expr04.
- 5: conjunction:  expr05, s, ("&&"; "and"), s, expr06.
- 6: negation:  NOT, s, expr06.
- 7: in:  expr07, s, "in", s, expr08.
  /(And so also for ~eq~, ~lt~, ~gt~, ~le~, ~gt~, ~not-in~, etc.)/
- 8: quantified-expression: QUANT, s, expr07.
  /(For QUANT in: ~no~, ~some~, ~lone~, ~one~, ~set~, ~seq~.)/
- 9: bit-shift: expr09, s, ("<<"; ">>"; ">>>"), s, expr10.
- 10: union, difference: expr10, s, ["+-"], s, expr11.
- 11: cardinality: "#", s, expr12.
- 12: override: base-12, s, "++", s, overlay-13.
- 13: intersection:  expr13, s, "&", s, expr14.
- 14: arrow-expr: expr14, s, (left-mult, s)?, -"->", s, (right-mult, s)?, expr15.
- 15: left-restriction: lr-set-15, s, "<:", s, lr-rel-16.
- 16: right-restriction: rr-rel-16, s, ":>", s, rr-set-17.
- 17: box-join:  expr17, "[", s, (selector-10 ++ comma, s)?, "]".
- 18: dot-join: expr18, s, ".", s, expr19.
- 19: inverse, closure: ["~^*"], s, expr20.
- 20: base expressions:  names, numbers, (...), {...}.

Note at level 17 that box-join is syntactically the same as function
application.  The choice of level-10 expressions for /selector/ is a
guess: in box-join (as in dot-join), selectors denote relations, so
formulas like those at levels 1-6 and values like those at levels 7-9
seem implausible.  If we ever need needing logical expressions as
function arguments, we'll need parentheses.  (Or maybe we should just
use /expr/.)

This multi-leveled definition of /expr/ comes close to describing the
sentences accepted by the Alloy Analyzer and producing appropriate
trees, but there are some cases where this grammar requires
parentheses in inputs accepts without parentheses by the Analyzer; see
the discussion of [[#BOP-POP][unary and binary operators and their interaction]]
below.

*** /Let/ expressions, quantified expressions (/expr01/)
:PROPERTIES:
:CUSTOM_ID: expr01
:END:

#+BEGIN_SRC ixml :tangle yes
-expr: expr01.

{ expr01:  Weakest binding:  let, quantified statements }
-expr01: let-expr;
         all-ex01; none-ex01; some-ex01; lone-ex01; one-ex01; sum-ex01; 
         expr02.

let-expr:  -"let", s, let-decl++comma, s, block-or-bar.
let-decl: variable, s, -"=", s, value.
value: expr.

{ quantified expressions }
all-ex01:  -"all",  S, decl++comma, s, block-or-bar.
none-ex01: -"no",   S, decl++comma, s, block-or-bar.
some-ex01: -"some", S, decl++comma, s, block-or-bar.
lone-ex01: -"lone", S, decl++comma, s, block-or-bar.
one-ex01:  -"one",  S, decl++comma, s, block-or-bar.
sum-ex01:  -"sum",  S, decl++comma, s, block-or-bar.
#+END_SRC

For now /block-or-bar/ is defined as containg /expr/.  I think that that
may be all right, but it has not been tested.

In both /J/ and /G/, ~let~ expressions are defined thus:
#+BEGIN_SRC Jebnf :tangle no
expr ::= "let" letDecl,+ blockOrBar.
letDecl ::= name "=" expr
#+END_SRC

The various quantified expressions are instances of a single pattern:
#+BEGIN_SRC ebnf4 :tangle no
expr ::= quant decl,+    blockOrBar.
#+END_SRC

*** Disjunctions (/expr02/)

#+BEGIN_SRC ixml :tangle yes
{ expr02:  disjunctions }
-expr02:  disjunction; expr03.
disjunction:  expr02, OR, expr03.
OR: s, -"||", s; S, -"or", S.
#+END_SRC

In /J/ and /G/, disjunctions are the first of many instances of
the pattern shown for all binary operators:

#+BEGIN_SRC ebnf4 :tangle no
expr ::= expr binOp expr.  
#+END_SRC

*** Bi-implications (/expr03/)
Bi-implication is another binary operator.
#+BEGIN_SRC ixml :tangle yes
{ expr03:  bi-implication }
-expr03:  bi-implication; expr04.
bi-implication:  expr03, IFF, expr04.
IFF: s, -"<=>", s; S, -"iff", S.
#+END_SRC

*** Implications (/expr04/)
Conditionals / implications are right-associative:  an embedded
implication can appear within either sub-clause.

Note that implications may be formulas or just expressions.
A first cut would be:
#+BEGIN_SRC ixml :tangle no
{ expr04:  implication -- dummy first cut }
-expr04:  implication; expr05.
implication:  expr04, s, 
              ("=>"; "implies"), s, expr04, s, 
              "else", s, expr04.
#+END_SRC

/J/ and /G/ give the form thus:
#+BEGIN_SRC ebnf4 :tangle no
expr ::= expr ("=>"|"implies") expr "else" expr.
#+END_SRC

Note that this production makes the ~else~ clause obligatory,
although the informal example on p. 69 of the book lacks a
trailing ~else~.

If trailing ~else~ is really optional, then the then-clause should
be rewrittten here to refer to /expr05/ not /expr04/.  Otherwise
we end up with the classic dangling-else problem of Algol 60.

[Later.  Hmmm.]  We seem to have an issue.  Since "=>" is included in
the definition of /binOp/ in /J/ and /G/, the expression "~A => B~" is
clearly grammatical.  In addition, page 263 says "So, for example, /p
=> q => r/ is parsed as /p => (q => r)/", and "In an implication, an
else-clause is associated with its closest then-clause."

Can we enforce the nearest-then-clause rule grammatically?

Consider the simple case "if a then if b then c else d".  The rule
says we want the parse tree for this case to be
[[file:../images/ifthenelse-1.dot.png]]
and not
[[file:../images/ifthenelse-2.dot.png]]

The diagrams distinguish /if-then/ expressions from /if-then-else/
expressions, and the rule appears to amount to saying that an /if-then/
expression is not allowed in the /then/-clause of an /if-then-else/
expression.  To be painfully explicit:

- In the /then/-clause of an /if-then/:
  + /if-then/ is OK.
  + /if-then-else/ is OK.
- In the /then/-clause of an /if-then-else/:
  + /if-then/ is not OK.
  + /if-then-else/ is OK.

Or in tabular form:
|---------------------+-----------------+----------------------|
|                     | Parent: if-then | Parent: if-then-else |
|---------------------+-----------------+----------------------|
| Child: if-then      | OK              | not OK               |
| Child: if-then-else | OK              | OK                   |
|---------------------+-----------------+----------------------|

We can, I think, express this by subdividing /expr04/ into two
levels of precedence.

#+BEGIN_SRC ixml :tangle yes
{ expr04:  implication }
-expr04:  if-then; expr04-bis.
-expr04-bis: if-then-else; expr05.
if-then:  condition, IMPLIES, consequent.
if-then-else:  condition, 
               IMPLIES, 
               then-clause, S, 
               else-clause.
IMPLIES: s, -"=>", s; S, -"implies", S.
condition: expr05.
consequent: expr04.
then-clause: expr04-bis.
else-clause: -"else", S, expr04.
#+END_SRC
We give the then-clause two different names in order to
capture the required difference in allowed content.

*** Conjunctions (/expr05/)

#+BEGIN_SRC ixml :tangle yes
{ expr05:  conjunction }
-expr05:  conjunction; expr06.
conjunction:  expr05, AND, expr06.
-AND: s, -"&&", s; S, -"and", S.
#+END_SRC

*** Negated expressions (/expr06/)

Jackson appears not to say explicitly that negation is
right-associative, but it cannot be left-associative
and I think it's probably a bad idea to try to say that
a double negation requires parentheses. 
#+BEGIN_SRC ixml :tangle yes
{ expr06:  negated expressions }
-expr06:  negation; expr07.
negation:  NOT, expr06.
NOT: -"!", s; -"not", S.
#+END_SRC

In /J/ and /G/, negation is just an instance of /unOp/:
#+BEGIN_SRC ebnf4 :tangle no
expr ::= unOp expr.
#+END_SRC

*** Comparisons and negated comparisons (/expr07/)

Since Alloy allows negation symbols both on the overall comparison
(e.g. "~not x < y~") and on the comparison operator (e.g. "~x not < y~"),
comparisons and their negations are a little more complex than
other binary operators.

#+BEGIN_SRC ixml :tangle yes
{ expr07: comparisons } 
-expr07:  comparison; expr08.
-comparison: in; eq; lt; gt; le; ge;
             not-in; not-eq; not-lt; not-gt; not-le; not-ge.
in:  expr07, S, -"in", S, expr08.
eq:  expr07, s, -"=",  s, expr08.
lt:  expr07, s, -"<",  s, expr08.
gt:  expr07, s, -">",  s, expr08.
le:  expr07, s, -"=<", s, expr08.
ge:  expr07, s, -">=", s, expr08.
not-in:  expr07, S, NOT, -"in", S, expr08.
not-eq:  expr07, s, NOT, -"=",  s, expr08.
not-lt:  expr07, s, NOT, -"<",  s, expr08.
not-gt:  expr07, s, NOT, -">",  s, expr08.
not-le:  expr07, s, NOT, -"=<", s, expr08.
not-ge:  expr07, s, NOT, -">=", s, expr08.
#+END_SRC

/J/ and /G/ have:
#+begin_src ebnf4 :tangle no
expr ::= expr ["!"|"not"] compareOp expr.
#+end_src
*** Expression quantifiers and multiplicities (/expr08/)
Quantifiers may be used not only on formulas (see [[#expr01][above]])
but also on expressions.  Here, the quantifiers are classed
as unary operators.

#+BEGIN_SRC ixml :tangle yes
{ expr08: quantified expressions } 
-expr08: quantified-expression; 
         expr09.
-quantified-expression: no-ex08; some-ex08; lone-ex08; one-ex08; 
         set-ex08; seq-ex08.
no-ex08: -"no", S, expr09.
some-ex08: -"some", S, expr09.
lone-ex08: -"lone", S, expr09.
one-ex08: -"one", S, expr09. 
set-ex08: -"set", S, member-type.
-member-type: expr09.
seq-ex08: -"seq", S, expr09.
#+END_SRC

The names chosen are awkward; it is hoped that some experimentation
and examination of examples will suggest better names which convey
more information about the difference between the expressions
dominated by quantifiers at levels /expr01/ and /expr08/.  For now,
the awkwardness is partly intentional: to underscore my current
imperfect understanding.

For comparison, expressions dominated by unary operators are defined
as follows in /J/ and /G/:
#+BEGIN_SRC Jebnf :tangle no
expr ::= unOp expr.
#+END_SRC

*** Bit-shifting operators (/expr09/)

The grammar file defines operators "<<", ">>", and ">>>" at precedence
level 9.  These are not documented in Jackson's book¸but in the
[[http://alloytools.org/quickguide/a4.html][supplementary documentation of Alloy 4]] on the Alloy Tools web site, they are
identified as left shift ("~<<~"), sign-extended right shift ("~>>~"),
and zero-extended right shift ("~>>>~").  The Alloy.cup grammar of
Alloy 6 assigns them the names SHL, SHA, and SHR, respectively.
Both operands should be /int/ values.

/G/ defines them as binary operators, so we'll follow the usual
pattern for them.

#+BEGIN_SRC ixml :tangle yes
{ expr09: bit-shifting expressions } 
-expr09: SHL-expr; SHR-expr; SHA-expr; expr10.
SHL-expr: expr09, s, -"<<", s, expr10.
SHR-expr: expr09, s, -">>>", s, expr10.
SHA-expr: expr09, s, -">>", s, expr10.
#+END_SRC

*** Union and difference (/expr10/)

#+BEGIN_SRC ixml :tangle yes 
{ expr10: union, set difference }
-expr10:  union; set-diff; expr11.
union: expr10, s, -"+", s, expr11.
set-diff: expr10, s, -"-", careful-ws, expr11.
#+END_SRC

Note that whitespace is required after the 

*** Cardinality (#) (/expr11/)

#+BEGIN_SRC ixml :tangle yes
{ expr11: cardinality }
-expr11:  cardinality; expr12.
cardinality: -"#", s, expr12.
#+END_SRC

*** Override (++) (/expr12/)
To try to guide later readers, we give distinct
names to the two operands of "~++~".  The left-hand
operand is the /base/ relation, the right-hand operand
is the /overlay/. 
#+BEGIN_SRC ixml :tangle yes 
{ expr12: override expressions }
-expr12: override; expr13.
override: base, s, -"++", s, overlay.
base: expr12.
overlay: expr13.
#+END_SRC

*** Intersection (&) (/expr13/)

#+BEGIN_SRC ixml :tangle yes 
{ expr13: intersection }
-expr13:  intersection; expr14.
intersection:  expr13, s, -"&", s, expr14.
#+END_SRC

*** Arrow product (->) (/expr14/)
Arrow operators are used to define relations.  They get
a little complex because they can specify multiplicity
on each side of the operator.
#+BEGIN_SRC ixml :tangle yes
{ expr14: arrow expressions }
-expr14: arrow-expr; expr15.
arrow-expr: expr14, (S, left-mult)?, s, -"->", s, (right-mult, S)?, expr15.
left-mult:  -mult; "set".
right-mult:  -mult; "set".
#+END_SRC

/J/ and /G/ have:
#+begin_src ebnf4
expr ::= expr arrowOp expr.
#+end_src
*** Restriction operators (<: and :>) (/expr15/, /expr16/)
Out of blind faith in generality, I follow Jackson's statement that
binary operators are left-associative, although anyone who has an
intuitive notion that one parse tree for an expression like "~a :> b
<: c <: d~" is distinctly more natural than any other is apparently
possessed of an intuition quite unlike mine.  (For one thing, one
argument should be a relation and the other a set, that is a singleton
relation.)  It would surprise me if any restriction operator found in
the wild immediately dominated any other restriction operator, and
still more if a human wrote such an expression without using
parentheses.  But I've been surprised before.  So by all means, each
of these is left-associative.

Thinking about this, I remind myself that I often have to look the
restriction operators up when I want to use them, because I forget
which way they point.  So for both left- and right-restriction, I'm
going to name the operands as a set or a rel[ation].
#+BEGIN_SRC ixml :tangle yes
{ expr15, 16: left and right restriction }
-expr15: left-restriction; expr16.
-expr16: right-restriction; expr17.
left-restriction: lr-set, s, -"<:", s, lr-rel.
right-restriction: rr-rel, s, -":>", s, rr-set.
lr-set: expr15.
lr-rel: expr16.
rr-rel: expr16.
rr-set: expr17.
#+END_SRC

*** Box join (/expr17/)
It is not clear what kind of expressions should be allowed within the
box.  I've put /expr10/ on the theory that they will normally be
relation-valued, and added /if-then-else/ because I have observed
that they can be (and are in some examples) relation-valued conditionals.
White space is allowed before the left square
bracket, because the examples show it being used.
#+BEGIN_SRC ixml :tangle yes
{ expr17: box joins }
-expr17: box-join; expr18.
box-join: box-left, s, -"[", s, (selector ++ comma, s)?, -"]".
box-left: expr17; sum; integer-cast.
selector: expr10; if-then-else.
sum: -"sum".
integer-cast: -"int".
#+END_SRC

/J/ and /G/ have:
#+begin_src ebnf4
expr ::= expr "[" expr,* "]".
#+end_src

It should be noted that box join is syntactically identical
to function or predicate application.  Some discussion may be
helpful, since the relation may not be intuitively obvious.
Functions are treated in Alloy as relations (following the model
of Z), so a function declared
#+begin_src Alloy
fun f [x : A] : B { ... }
#+end_src
is effectively a set of (/A/, /B/) pairs.  The expression ~f[a]~
is defined as equivalent to ~a.f~, and returns the atoms in set /B/
which are the images of ~a~ in the functional relation /f/.

If the function has more than one argument, its name denotes a
relation of appropriate arity.  Suppose /f/ has the signature /A/ ×
/B/ × /C/ × /D/, and ~a~, ~b~, ~c~ are atoms in sets /A/, /B/, /C/
respectively.  The expression ~f[a,b,c]~ is equivalent (see p. 279) to
~f[a][b][c]~ and thus to ~(a.f)[b][c]~, ~(b.(a.f))[c]~,
~(c.(b.(a.f))~.  The type of /f/ is /A/ × /B/ × /C/ × /D/, so the type
of ~a.f~ is /B/ × /C/ × /D/, the type of ~b.(a.f)~ is /C/ × /D/, and
the type of the entire expression is /D/.

Predicates could perhaps be regarded as a tuple formed from the
arguments with an added Boolean value at the end, but since Alloy does
not have a Boolean type, that view is necessrily metalinguistic and
cannot be expressed in Alloy.  

*** Dot join (/expr18/)
#+BEGIN_SRC ixml :tangle yes
{ expr18: dot joins }
-expr18: dot-join; expr19.
dot-join: expr17, s, -".", s, expr19.
#+END_SRC

Note that we define /dot-join/ as accepting /expr17/ on its
left side, in order to allow box-join in the left operand.
(In chapter 6, the assertion /PasteNotAffectHidden/ [p. 213]
includes the subexpression ~xs'.catalogState[c].hidden~,
which in context.)
*** Tightly binding unary operators (/expr19/)
It's not completely clear whether Alloy 4 intends these three unary
operators to be right-associative or non-associative.  The Alloy 6
CUP grammar declares them non-associative, so that's how they were
initially defined here.

But the sample model in ~examples/algorithms/opt_spantree.als~
includes the expression ~Process in Root.*~(s.parent)~, where they
are clearly meant to be right-associative.
#+BEGIN_SRC ixml :tangle yes
{ expr19: inverse, closures }
-expr19: inverse; t-closure; rt-closure; expr20.
inverse: -"~", s, expr19.
t-closure: -"^", s, expr19.
rt-closure: -"*", s, expr19.
#+END_SRC

*** Base expressions

There are several forms of expression which contain no operators; we
define them here.

#+BEGIN_SRC ixml :tangle yes
{ expr20: base expressions }
-expr20:  OQName;
          unexpanded;
          THIS;
          NONE; IDEN; UNIV; { named sets, parse as name }
          INT; SEQINT; 
          number; 
          negative-number;
          -"(", s, expr, s, -")";
          declarations-block;
          block.
unexpanded: -"@", s, name.
negative-number: -"-", -number.
declarations-block: -"{", s, 
                    decl ++ comma, s, 
                    block-or-bar, s, -"}".
#+END_SRC

The keywords "none", "iden", "univ", "Int", and "seq/Int" are
predefined names denoting the empty set, the identity relation, the
universal set, and so on.  If we include them in the ixml grammar, any
module that uses any of them will be ambiguous, since they can all be
parsed as /OQName/, and ixml does not have any mechanism for saying to
prefer the keyword parse over the other.  So we omit them and tell the
user of the XML to watch out for ~<name>univ</name>~ and the like, and
handle it appropriately.


** Blocks
A block is just a sequence of expressions enclosed in braces; in some
contexts, the braces will determine the scope of some relevant
declaration.

In several constructs, a declaration is separated from the expression
it governs by a vertical bar.  If the declaration should govern
multiple expressions, the bar and expression can be replaced by a
brace-delimited block.  That idiom is expressed in the grammar by the
nonterminal /block-or-bar/.

#+BEGIN_SRC ixml :tangle yes
block: -"{", s, (expr++S, s)?, -"}".
block-or-bar: block;
              -"|", s, expr.
#+END_SRC

/J/:
#+BEGIN_SRC Jebnf :tangle no
block ::= "{" expr* "}"
blockOrBar ::= block | bar expr
bar ::= "|"
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
block ::= "{" expr* "}"
blockOrBar ::= block
blockOrBar ::= "|" expr
#+END_SRC



* Low-level constructs

** Names and numbers
:PROPERTIES:
:CUSTOM_ID: names-nums
:END:

Note: Grammar /G/ uses /name/ and /ID/ where grammar /J/ 
uses /qualName/ and /name/.  Since I want a bare name when possible, a
wrapped name sequence where necessary, I use /OQName/ (i.e. optionally
qualified name) where B has /qualName/.  So we should have

- /OQName/ matches either a /qualName/ or a /name/.  The nonterminal
  is never serialized.
- /qualName/ matches a name with a non-empty qualifier.  
- /name/ matches an unqualified identifier.

The nonterminals /qualName/ and /name/ are typically serialized,
unless a more informative nonterminal name is provided.

#+BEGIN_SRC ixml :tangle yes
ref: OQName | UNIV | INT | SEQINT.

-OQName:  qual-name; name.

{ qualName: ("this", "/")?, name++slash. }
{ qual-name: THIS, "/", name++slash
           | name, "/", name++slash. }
qual-name: THIS, -"/", (qual, -"/")*, name
         | (qual, -"/")+, name.
{ qual: ID. }
qual: -name-minus-reserved-words.

number: '0'; ['1'-'9'], digit*.
-digit: ['0'-'9'].

-ID: letter, (letter; digit; '_'; sq; dq)*.
-letter: ['a'-'z'; 'A'-'Z'].
-sq: "'" { single quote ' }.
-dq: '"' { double quote " }.
#+END_SRC

For reasons which will become clear later, we want the definition of
/name/ in a separate code block.

It would be simple to define /name/ as just an /ID/, but that does not
work.
#+begin_src ixml :tangle no
name: ID.
#+end_src

/J/ uses /qualName/ where we have /OQName/, and treats /name/ as a
primitive lexical token.
#+BEGIN_SRC Jebnf :tangle no
qualName ::= ["this/" ] (name "/")* name
#+END_SRC

/G/, on the other hand, uses /name/ where /J/ has /qualName/.
#+BEGIN_SRC ebnf4 :tangle no
name ::= ("this" | ID) ["/" ID]*
ref ::= name | "univ" | "Int" | "seq/Int"  
#+END_SRC

Note: the definition of name given above introduces ambiguities
because any reserved word (e.g. "and" or "else") also parses as an
/ID/ and thus as a /name/.  A possible solution to the ensuing
problems (a more complicated definition that excludes the
reserved words) is given [[#names-minus][below]].

Note that Jackson specified (p. 260) that "A numeric constant consists
of a sequence of digits between 0 and 9, whose first digit is not zero."
But the Analyzer accepts "~0~" as a numeric constant (e.g. in
~/examples/algorithms/stable_ringlead.als~).  So the definition of
/number/ above has been modified to include "0".

** Multiplicities and quantifiers

#+BEGIN_SRC ixml :tangle yes
quant: "all" | "no" | -mult | "sum".
mult: "some" | "lone" | "one".
#+END_SRC

/J/ defines both /mult/ and /quant/:
#+BEGIN_SRC Jebnf :tangle no
mult ::= "lone" | "some" | "one"
#+END_SRC
#+BEGIN_SRC Jebnf :tangle no
quant ::= "all" | "no" | "sum" | mult
#+END_SRC

/G/ has no /mult/ production.
#+BEGIN_SRC ebnf4 :tangle no
quant ::= "all" | "no" | "some" | "lone" | "one" | "sum"
#+END_SRC


** Operators
:PROPERTIES:
:CUSTOM_ID: ops
:END:

In the ixml grammar, these productions are unreachable (I hope)
and are here only for the moment.

#+BEGIN_SRC ixml :tangle no
binOp: "||" | "or" | "&&" | "and" | "&" | "<=>" | "iff"
        | "=>" | "implies" | "+" | "-" | "++" | "<:" | ":>" | "." | "<<" | ">>" | ">>>".

arrowOp: ("some"|"one"|"lone"|"set")?, "->", ("some"|"one"|"lone"|"set")?.

compareOp: "=" | "in" | "<" | ">" | "=<" | ">=".

unOp: "!" | "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | "#" | "~" | "*" | "^".
#+END_SRC

In order to get more informative nonterminal names, we have
embedded each operator into a distinctive production.  Both /J/
and /G/, however, make the grammar briefer by handling operators
generically.

*** Unary operators
/J/ has:
#+BEGIN_SRC Jebnf :tangle no
unOp ::= "!" | "not" | "no" | mult | "set" | "#" | "~" | "*" | "^"
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
unOp ::= "!" | "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | "#" | "~" | "*" | "^"
#+END_SRC

*** Binary operators
Both /J/ and /G/ distinguish arrow operators and comparison operators
from other binary operators.

/J/:
#+BEGIN_SRC Jebnf :tangle no
binOp ::= "||" | "or" | "&&" | "and" | "<=>" | "iff" | "=>" | "implies" |
   | "&" | "+" | "-" | "++" | "<:" | ":>" | "." 

arrowOp ::= [mult|"set"] "->" [mult|"set"]

compareOp ::= "in" | "=" | "<" | ">" | "=<" | ">="
#+END_SRC

/G/:
#+BEGIN_SRC ebnf4 :tangle no
binOp ::= "||" | "or" | "&&" | "and" | "&" | "<=>" | "iff"
        | "=>" | "implies" | "+" | "-" | "++" | "<:" | ":>" | "." | "<<" | ">>" | ">>>"

arrowOp ::= ["some"|"one"|"lone"|"set"] "->" ["some"|"one"|"lone"|"set"]

compareOp ::= "=" | "in" | "<" | ">" | "=<" | ">="
#+END_SRC


*** Precedence
/G/ starts with a list of operator precedence values (low to high):

1.    let    all a:X|F   no a:X|F   some a:X|F   lone a:X|F   one a:x|F   sum a:x|F
2.    ||
3.    <=>
4.    =>     => else
5.    &&
6.    !
7.    in     =        <        >       <=      >=      !in   !=   !<   !>  !<=  !>=
8.    no X   some X   lone X   one X   set X   seq X
9.    <<     >>       >>>
10.   +      -
11.   #X
12.   ++
13.   &
14.   ->
15.   <:
16.   :>
17.   []
18.   .
19.   ~    *     ^

All binary operators are left-associative, except the arrow operators (~->~),
the implication (~a=>b~), and if-then-else (~a=>b else c~).


** Constants
/J/:
#+BEGIN_SRC Jebnf :tangle no
const ::= ["-"] number | "none" | "univ" | "iden"
#+END_SRC

In /G/, constants are not separately identified.

** Separators

#+BEGIN_SRC ixml :tangle yes
-comma: s, -",", s.
slash: s, -"/", s.
plus:  s, -"+", s.
#+END_SRC

** Whitespace
#+BEGIN_SRC ixml :tangle yes
-S = (ws_char | comment)+.
-s = S?.

-ws_char: -[#20; #9; #A; #D]. 
{ ws_char: SP; TAB; LF; CR.
SP: #20.
TAB: #9.
LF: #A.
CR: #D. }
#+END_SRC

** Comments
There are two kinds of comments: from "//" or "--" to the end of the
line, and from "~/*~" to "~*/~".  The one-liners are fairly
straightforward.  We distinguish them in order to specify that
following the set-difference operator "-" no double-hyphen comment may
immediately follow.  (The example on page 300 of /SA/ is otherwise
ambiguous because of the comment reading "~------------- bug! (see
page 306)~".)

#+BEGIN_SRC ixml :tangle yes
comment:  double-slash; double-hyphen; slash-star.
-double-slash:  -"//", ~[#A; #D]*, NL.
-double-hyphen: -"--", ~[#A; #D]*, NL.
-NL: -#D?, -#A.
careful-ws: ((ws_char; double-slash; slash-star), s)?.
#+END_SRC

Slash-star comments don't nest and /slash-star/ thus defines a regular
language.  For reasons which may be pragmatic or merely quixotic, I'd
like to define the non-terminal with a single production rule with a
regular expression on the right-hand side.  But experience shows that
getting the regular expression correct can be tricky.  (Put it this
way: it took the XML working group at least two weeks to get the
definition of XML comments correct.  And we did so by abandoning
conventional regular-expression syntax and introducing the
set-difference operator.)

But it is not hard to describe the desired language with a
finite state automaton which is simple enough to inspire some
confidence.

*** Slash-star, first cut

The following FSA describes the language of slash-star comments
in a straightforward way.

[[file:../images/slash-star.dot.png]]

This, in turn, can be translated readily into a regular grammar:

#+BEGIN_SRC ixml :tangle no
      slash-star: -"/*", looking-for-star.
looking-for-star: ~["*"], looking-for-star
                | "*", found-star.
      found-star: "/", end-comment
                | "*", found-star
                | ~["/"; "*"], looking-for-star.
     end-comment: {}.
#+END_SRC 

From this, we can derive a regular expression by systmatically
modifying the grammar.

1. Apply Arden's Lemma to /looking-for-star/ to get
   #+BEGIN_SRC ixml :tangle no
   looking-for-star: ~["*"]*, "*", found-star.
   #+END_SRC 

2. Expand /looking-for-star/ in the last line of /found-star/ to get:
   #+BEGIN_SRC ixml :tangle no
   found-star: "/", end-comment
             | "*", found-star
             | ~["/"; "*"], ~["*"]*, "*", found-star.
   #+END_SRC 

3. Fold the second and third lines of /found-star/ together to get:
   #+BEGIN_SRC ixml :tangle no
   found-star: "/", end-comment
             | ("*" | (~["/"; "*"], ~["*"]*, "*")), found-star.
   #+END_SRC 

4. Simplify in the second line of /found-star/ to get:
   #+BEGIN_SRC ixml :tangle no
   found-star: "/", end-comment
             | (~["/"; "*"], ~["*"]*)?, "*", found-star.
   #+END_SRC 

5. Apply Arden's Lemma to /found-star/:
   #+BEGIN_SRC ixml :tangle no
   found-star: ((~["/"; "*"], ~["*"]*)?, "*")*, "/", end-comment.
   #+END_SRC 

   We now have:
   #+BEGIN_SRC ixml :tangle no
   slash-star: -"/*", looking-for-star.
   looking-for-star: ~["*"]*, "*", found-star.
   found-star: ((~["/"; "*"], ~["*"]*)?, "*")*, "/", end-comment.
   end-comment: {}.
   #+END_SRC 

6. The nonterminals /end-comment/, /found-star/, and
   /looking-for-star/ can now be expanded in place:
   #+BEGIN_SRC ixml :tangle no
   slash-star: -"/*", ~["*"]*, "*", ((~["/"; "*"], ~["*"]*)?, "*")*, "/".
   #+END_SRC 

This gives us the desired single-rule definition of /slash-star/.
#+BEGIN_SRC ixml :tangle no
-slash-star: -"/*", ~["*"]*, "*", ((~["/"; "*"], ~["*"]*)?, "*")*, "/".
#+END_SRC

*** Slash-star, second and third cuts

There is, however, a problem with the development just given.  The
closing delimiter "=*/=" is not given as a single string, so it cannot
be conveniently suppressed in the XML.  The final slash can, but the
star immediately in front of it cannot, because it's not uniquely
identified.  I noticed this problem only after completing the analysis
above.

The problem goes all the way back to the FSA we started with, so we
have to do the development all over again.  Let's start with a
different FSA, in which both delimiters are given explicitly and
uniquely.

[[./../images/slash-star-bis.dot.png]]

This FSA is simpler than the previous one; we might be able to turn it
into a regular expression without complicated development.  Out of an
abundance of caution (justified by experience), however, let's start
with a regular grammar:

#+BEGIN_SRC ixml :tangle no
          slash-star: -"/*", ready-for-star-slash.
ready-for-star-slash: ~["*"], ready-for-star-slash
                    | "*", found-star
                    | "*/", end-comment.
          found-star: ~["/"], ready-for-star-slash
                    | {nil} ready-for-star-slash.
         end-comment: {}.
#+END_SRC
Unlike the earlier FSA, this one is non-deterministic: it requires a
two-character lookahead to distinguish an asterisk which is followed
by a slash and thus part of the comment-closing delimiter from any
other asterisk.  But neither ixml nor most regular-expression libraries
require deterministic regular expressions.

A simple first step is to simplify /found-star/:
#+BEGIN_SRC ixml :tangle no
          found-star: ~["/"]?, ready-for-star-slash.
#+END_SRC

We can then substitute for /found-star/ in the rule for
/ready-for-star-slash/:
#+BEGIN_SRC ixml :tangle no
          slash-star: -"/*", ready-for-star-slash.
ready-for-star-slash: ~["*"], ready-for-star-slash
                    | "*", ~["/"]?, ready-for-star-slash
                    | "*/", end-comment.
         end-comment: {}.
#+END_SRC

Applying Arden's Lemma to /ready-for-star-slash/ yields a rule with a
single right-hand-side:
#+BEGIN_SRC ixml :tangle no
          slash-star: -"/*", ready-for-star-slash.
ready-for-star-slash: (~["*"] | "*", ~["/"]?)*, "*/", end-comment.
         end-comment: {}.
#+END_SRC

This can be turned into a single-rule definition of slash-star comments:
#+BEGIN_SRC ixml :tangle no
-slash-star: -"/*", (~["*"] | "*", ~["/"]?)*, -"*/". 
#+END_SRC
However, this definition is faulty, because it is not cautious
enough about the slash character.

Note:  the initial attempt at this revised definition was simpler:
#+BEGIN_SRC ixml :tangle no
-slash-star: -"/*", ~[]*, -"*/". 
#+END_SRC
But this does not prohibit the string star-slash from appearing
within a comment.

*** Slash-star, fourth cut

Let us try again, with yet another FSA:

[[file:../images/slash-star-ter.dot.png]]

A listeral translation into a regular grammar produces the following.
#+BEGIN_SRC ixml :tangle no
      slash-star: -"/*", looking-for-star.
looking-for-star: ~["*"], looking-for-star
                | "*", found-star
                | "*/", end-comment.
      found-star: "*/", end-comment
                | "*", found-star
                | ~["/"; "*"], looking-for-star.
     end-comment: {}.
#+END_SRC 

Again, we derive the rule we want by manipulating this grammar.

1. Applying Arden's Lemma to /found-star/, and then distributing
   concatenation over disjunction, we get:
   #+begin_src ixml :tangle no
      found-star: "*"*, "*/", end-comment
                | "*"*, ~["/"; "*"], looking-for-star.
   #+end_src
2. Substituting this into /looking-for-star/ and re-ordering the
   right-hand sides, we get:
   #+begin_src ixml :tangle no
looking-for-star: ~["*"], looking-for-star
                | "*", "*"*, ~["/"; "*"], looking-for-star
                | "*", "*"*, "*/", end-comment
                | "*/", end-comment.
   #+end_src
3. Simplifying the right-hand sides and merging the last two yields:
   #+begin_src ixml :tangle no
looking-for-star: ~["*"], looking-for-star
                | "*"+, ~["/"; "*"], looking-for-star
                | "*"*, "*/", end-comment.
   #+end_src
4. Applying Arden's Lemma gives us:
   #+begin_src ixml :tangle no
looking-for-star: (~["*"] | "*"+, ~["/"; "*"])*, "*"*, "*/", end-comment.
   #+end_src

From this, we can derive a single-rule formulation:
#+begin_src ixml :tangle yes
-slash-star: -"/*", (~["*"] | "*"+, ~["/"; "*"])*, "*"*, -"*/".
#+end_src

It may be noted that a set-difference operator would
simplify this to:
#+begin_src ixml :tangle no
-slash-star: -"/*", (anystring except (anystring, '*/', anystring), "*/".
 -anystring: ~[]*.
#+end_src
which may be paraphrased in English as: a slash-star comment is "/*",
followed by any string which does not contain "*/", followed by "*/".


** Keywords

Are these used?  Should they be?

#+BEGIN_SRC ixml :tangle yes
THIS: "this".
PRIVATE:  "private".
UNIV: "univ".
INT: "Int".
SEQINT: "seq/Int".
NONE: "none".
IDEN: "iden".
private: "private".
abstract: "abstract".
EXACTLY: "exactly".
#+END_SRC



* Miscellaneous

There is some stuff that doesn't have a good home.  Some of it I don't know anything about.

** Enumerations
Enumerations are not present in /J/ but are added as a new
form of paragraph in /G/.

#+BEGIN_SRC ixml :tangle yes
enum-decl: -"enum", s, name, s, -"{", s, name++comma, s, -"}".
#+END_SRC

/G/ defines them thus:
#+BEGIN_SRC ebnf4 :tangle no
enumDecl ::= "enum" name "{" name  ("," name)*  "}"
#+END_SRC


** Avoiding ambiguity between keywords and names
:PROPERTIES:
:CUSTOM_ID: names-minus
:END:

Defining /name/ and /ID/ as done [[#names-nums][above]] is sub-optimal, because it
means that keywords are all also recognizable as names.  Perhaps we
can derive a suitable grammar by starting from a simple FSA, as was
done for comments.

The following keywords are reserved:
abstract, all, and, as, assert,
but,
check,
disj,
else, exactly, extends,
fact, for, fun,
iden, iff, implies, in,
Int,
let, lone,
module,
no, none, not,
one, open, or,
pred,
run,
set, sig, some, sum,
univ.

For the record (it will matter at some point), the Alloy 6 grammar
also appears to have: enum, expect, int (lowercase), private, seq,
String, this, NAME, NUMBER, STRING, var, always, eventually, after,
before, historically, once, releases, until, since, triggered, steps.
(I say "appears to have" because I'm not finding the CUP file
completely clear.)

Alloy 6 may also have the spellings "disjoint" and "<=".  At first
glance I thought it also added the keyword "trace", but I now think
that that was just a gloss on ";", the trace-sequence operator.

If we had a set subtraction operator, we could write:
#+begin_src ixml :tangle no
name: ID but-not reserved-word.

reserved-word: "abstract"; "all"; "and"; "as"; "assert"; 
               "but"; 
               "check";
               "disj";
               "else "; "exactly "; "extends";
               "fact "; "for "; "fun"; 
               "iden "; "iff "; "implies "; "in"; 
               "Int"; 
               "let "; "lone"; 
               "module"; 
               "no "; "none "; "not"; 
               "one"; "open"; "or"; 
               "pred"; "
               run"; 
               "set"; "sig"; "some"; "sum"; 
               "univ".
#+end_src

And similarly, if we had a priority operator, we could say that if
something can be parsed as either a /name/ or as the keyword ~else~,
the latter parse is to be preferred.

But we don't have a set subtraction operator, or a priority operator.
Since both /name/ and the list of reserved words are regular, we know
that we can express what we want as a regular language.

It should be possible in principle to devise an FSA analogous to the
one given above for slash-star comments, turn it into a grammar, and
then simplify the grammar, either partially or all the way into a
single regular expression.  But given these thirty-five reserved
words, there would be somewhat more than 100 states in the FSA; even
drawing it would be tedious, and manipulating the resulting regular
grammar would be rather error prone.

But the principle of the FSA is simple enough to describe: it has a
start state, and depending on the initial letter, the next state
reached is either

- a state in which we know that the /name/ we are about to match
  is not a keyword; or
- a state in which we have matched part of a keyword but not the
  entire keyword.

For the first of these, one state suffices.  When we have matched part
of a keyword, the state must depend on which keyword(s) we have
partially matched, and how much of them.  One state for each prefix of
each keyword. But I won't go into more detail.

For now, I will abandon thought of a regular expression and settle for
a comprehensible grammatical expression.

One form that is simple to understand is a rule with a flat set of
right-hand sides, one for each string which is a prefix (proper or
improper) of any reserved word.

For any such prefix /p/, one of three cases applies:

- /p/ is itself a reserved word (and not a prefix of any other
  reserved word).  E.g. "~assert~".

  We must require more characters, so the expression we
  want is "~'assert', namechar+~".
  
- /p/ is both a proper prefix of some reserved word /r/ and
  is itself a reserved word. E.g. "~as~".

  We must require more characters, and ensure that the characters
  added distinguish the string from /r/.  The easiest way is to
  require that it differ from /r/ in the next character.
  "~'as', nc-not-s, namechar*~".
  
- /p/ is a proper prefix of some reserved word /r/ and
  not itself a reserved word /t/.  E.g. "~asse~".

  We must accept /p/ as a name, and ensure that any name
  beginning with /p/ differs from /r/ in the next character
  after /p/.  So:  "~'asse', (nc-not-r, namechar*)?~".

Note the structural similarity between the second and third cases;
they differ only in that one requires a non-empty suffix to /p/ (so as
to ensure that /p/ itself is not accepted as a name), and the other
makes the suffix optional (because /p/ should be accepted as a name).

It will be convenient to have nonterminals meaning "any name character"
and "any name character except /x/" for some character /x/.

#+begin_src ixml :tangle yes
{ name characters:  possible continuations for a name }
-namechar: ["a"-"z";          "A"-"Z"; "0"-"9"; "_"; #27; #22].

{ The set of name characters, minus individual characters }
-nc-not-a: [         "b"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-b: ["a";     "c"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-c: ["a"-"b"; "d"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-d: ["a"-"c"; "e"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-e: ["a"-"d"; "f"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-f: ["a"-"e"; "g"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-g: ["a"-"f"; "h"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-h: ["a"-"g"; "i"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-i: ["a"-"h"; "j"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-j: ["a"-"i"; "k"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-k: ["a"-"j"; "l"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-l: ["a"-"k"; "m"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-m: ["a"-"l"; "n"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-n: ["a"-"m"; "o"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-o: ["a"-"n"; "p"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-p: ["a"-"o"; "q"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-r: ["a"-"q"; "s"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-s: ["a"-"r"; "t"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-t: ["a"-"s"; "u"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-u: ["a"-"t"; "v"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-v: ["a"-"u"; "w"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-x: ["a"-"w"; "y"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-y: ["a"-"x";     "z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-I: ["a"-"z"; "A"-"H"; "J"-"Z"; "0"-"9"; "_"; #27; #22].
#+end_src

It turns out that some times we want to exclude more than one name
character from the set.  After we have read an "a", for example, we
must be careful about the letters "b" (as in "~abstract~"), "l" (as in
"~all~"), "n" ("~and~'), and "s" ("~as~", "~assert~").

#+begin_src ixml :tangle yes
{ Some doubles and triples }
-nc-not-aou: ["b"-"n"; "p"-"t"; "v"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-at: ["b"-"s"; "u"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-blns: ["a"; "c"-"k"; "m"; "o"-"r"; "t"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-dfmn: ["a"-"c"; "e"; "g"-"l"; "o"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-eiou: ["a"-"d"; "f"-"h"; "j"-"n"; "p"-"t"; "v"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-eo: ["a"-"d"; "f"-"n"; "p"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-lx: ["a"-"k"; "m"-"w"; "y"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-npr: ["a"-"m"; "o"; "q"; "s"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-nt: ["a"-"m"; "o"-"s"; "u"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-qt: ["a"-"p"; "r"-"s"; "u"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
#+end_src

We also want a nonterminal defining the set of letters (possible
name-initial characters) which do not begin any keyword.

#+begin_src ixml :tangle yes
letter-no-abcdefiIlmnoprstu: ["ghjkqvwxyz"; "A"-"H"; "J"-"Z"].
#+end_src

And now we can define the nonterminal we want:

#+begin_src ixml :tangle yes
-name-minus-reserved-words = 
  -letter-no-abcdefiIlmnoprstu, namechar*;

  'a', (nc-not-blns, namechar*)? ; 
  'ab', (nc-not-s, namechar*)? ; 
  'abs', (nc-not-t, namechar*)? ; 
  'abst', (nc-not-r, namechar*)? ; 
  'abstr', (nc-not-a, namechar*)? ; 
  'abstra', (nc-not-c, namechar*)? ; 
  'abstrac', (nc-not-t, namechar*)? ; 
  'abstract', namechar+ ; 
  'al', (nc-not-l, namechar*)? ; 
  'all', namechar+ ; 
  'an', (nc-not-d, namechar*)? ; 
  'and', namechar+ ; 
  'as', nc-not-s, namechar* ; 
  'ass', (nc-not-e, namechar*)? ; 
  'asse', (nc-not-r, namechar*)? ; 
  'asser', (nc-not-t, namechar*)? ; 
  'assert', namechar+ ; 
  'b', (nc-not-u, namechar*)? ; 
  'bu', (nc-not-t, namechar*)? ; 
  'but', namechar+ ; 
  'c', (nc-not-h, namechar*)? ; 
  'ch', (nc-not-e, namechar*)? ; 
  'che', (nc-not-c, namechar*)? ; 
  'chec', (nc-not-k, namechar*)? ; 
  'check', namechar+ ; 
  'd', (nc-not-i, namechar*)? ; 
  'di', (nc-not-s, namechar*)? ; 
  'dis', (nc-not-j, namechar*)? ; 
  'disj', namechar+ ; 
  'e', (nc-not-lx, namechar*)? ; 
  'el', (nc-not-s, namechar*)? ; 
  'els', (nc-not-e, namechar*)? ; 
  'else', namechar+ ; 
  'ex', (nc-not-at, namechar*)? ; 
  'exa', (nc-not-c, namechar*)? ; 
  'exac', (nc-not-t, namechar*)? ; 
  'exact', (nc-not-l, namechar*)? ; 
  'exactl', (nc-not-y, namechar*)? ; 
  'exactly', namechar+ ; 
  'ext', (nc-not-e, namechar*)? ; 
  'exte', (nc-not-n, namechar*)? ; 
  'exten', (nc-not-d, namechar*)? ; 
  'extend', (nc-not-s, namechar*)? ; 
  'extends', namechar+ ; 
  'f', (nc-not-aou, namechar*)? ; 
  'fa', (nc-not-c, namechar*)? ; 
  'fac', (nc-not-t, namechar*)? ; 
  'fact', namechar+ ; 
  'fo', (nc-not-r, namechar*)? ; 
  'for', namechar+ ; 
  'fu', (nc-not-n, namechar*)? ; 
  'fun', namechar+ ; 
  'i', (nc-not-dfmn, namechar*)? ; 
  'id', (nc-not-e, namechar*)? ; 
  'ide', (nc-not-n, namechar*)? ; 
  'iden', namechar+ ; 
  'if', (nc-not-f, namechar*)? ; 
  'iff', namechar+ ; 
  'im', (nc-not-p, namechar*)? ; 
  'imp', (nc-not-l, namechar*)? ; 
  'impl', (nc-not-i, namechar*)? ; 
  'impli', (nc-not-e, namechar*)? ; 
  'implie', (nc-not-s, namechar*)? ; 
  'implies', namechar+ ; 
  'in', nc-not-t, namechar* ; 
  'int', namechar+ ; 
  'I', (nc-not-n, namechar*)? ; 
  'In', (nc-not-t, namechar*)? ; 
  'Int', namechar+ ; 
  'l', (nc-not-eo, namechar*)? ; 
  'le', (nc-not-t, namechar*)? ; 
  'let', namechar+ ; 
  'lo', (nc-not-n, namechar*)? ; 
  'lon', (nc-not-e, namechar*)? ; 
  'lone', namechar+ ; 
  'm', (nc-not-o, namechar*)? ; 
  'mo', (nc-not-d, namechar*)? ; 
  'mod', (nc-not-u, namechar*)? ; 
  'modu', (nc-not-l, namechar*)? ; 
  'modul', (nc-not-e, namechar*)? ; 
  'module', namechar+ ; 
  'n', (nc-not-o, namechar*)? ; 
  'no', nc-not-nt, namechar* ; 
  'non', (nc-not-e, namechar*)? ; 
  'none', namechar+ ; 
  'not', namechar+ ; 
  'o', (nc-not-npr, namechar*)? ; 
  'on', (nc-not-e, namechar*)? ; 
  'one', namechar+ ; 
  'op', (nc-not-e, namechar*)? ; 
  'ope', (nc-not-n, namechar*)? ; 
  'open', namechar+ ; 
  'or', namechar+ ; 
  'p', (nc-not-r, namechar*)? ; 
  'pr', (nc-not-e, namechar*)? ; 
  'pre', (nc-not-d, namechar*)? ; 
  'pred', namechar+ ; 
  'r', (nc-not-u, namechar*)? ; 
  'ru', (nc-not-n, namechar*)? ; 
  'run', namechar+ ; 
  's', (nc-not-eiou, namechar*)? ; 
  'se', (nc-not-qt, namechar*)? ; 
  'seq', namechar+ ; 
  'set', namechar+ ; 
  'si', (nc-not-g, namechar*)? ; 
  'sig', namechar+ ; 
  'so', (nc-not-m, namechar*)? ; 
  'som', (nc-not-e, namechar*)? ; 
  'some', namechar+ ; 
  'su', (nc-not-m, namechar*)? ; 
  'sum', namechar+ ;
  't', (nc-not-h, namechar*)? ;
  'th', (nc-not-i, namechar*)? ;
  'thi', (nc-not-s, namechar*)? ;
  'this', namechar+ ;
  'u', (nc-not-n, namechar*)? ; 
  'un', (nc-not-i, namechar*)? ; 
  'uni', (nc-not-v, namechar*)? ; 
  'univ', namechar+ .
#+end_src

Note that none of the nonterminals used in the production for
/name-minus-reserved-words/ is recursive.  So we can in fact, if we
wish, create a single regular expression by inlining all the
nonterminals (I mean, replacing each reference to /namechar/ with its
definition, and similarly for each of the other nonterminals).

Now we can define /name/ as any ID other than a reserved word:

#+begin_src ixml :tangle yes
name: -name-minus-reserved-words.          
#+end_src

Note that there are places where some or all of the predefined names
also need to be included.  
- "~none~"
- "~univ~"
- "~iden~"
- "~Int~"
- "~int~" 

In some cases, this is accomplished by using the nonterminal /ref/
instead of /name/ or /OQName/, to accept "~univ~", "~Int~", and
"~seq/Int~". In other cases, some or all predefined names are
mentioned explicitly.  In /expr20/ for example all of the above are
included explicitly (except "~int~", which may need adding); in
scopes, "~Int~" and "~seq/Int~" are handled specially.

The definition of name qualifiers calls out "~this~" specially;
it's not listed as a reserved word, but as far as I can tell
it functions as one.

An alternative approach would be to define them all as names; I tried
this, in the form shown below, but it did not work very well.
#+begin_src ixml :tangle no
name: -name-minus-reserved-words
    ; "iden"
    ; "int"
    ; "Int"
    ; "none"
    ; "univ"
    .
#+end_src

** Operator precedence and interactions of binary and unary operators
:PROPERTIES:
:CUSTOM_ID: BOP-POP
:END:

For the most part, the multi-level grammar for expressions given [[#expressions][above]]
accepts the same language as the Alloy Analyzer and produces the same
(or acceptably similar) parse trees.  But there are exceptions which
arise from the interaction of binary infix operators and unary prefix
(or suffix) operators.

When an operator-precedence table is used (as in the definition of
Alloy) to specify the binding strengths of operators, there appear to
be two ways to interpret the ordering.  One is to say that in any
abstract syntax tree produced from unparenthesized input, parent/child
relations will hold between operators of different binding strengths
only when the parent binds less tightly than the child. Thus in a
language with two left-associative binary operators Bop and BOP, in
which BOP binds tighter than Bop, the input
#+begin_example
a Bop b BOP c
#+end_example
will be parsed as a Bop expression whose left-hand operand is /a/ and
whose right-hand argument is a BOP.  To use the notation of Prolog
structures: Bop(a, BOP(b, c)). Since BOP is left-associative, then the
input
#+begin_example
a BOP b BOP c
#+end_example
will produce BOP(BOP(a, b), c).

Another way to interpret the precedence table is to say that when the
sentence would otherwise be ambiguous, the precedence table shows
which parse tree to prefer.  On the examples just given, it produces
the same results.  When an operand (in these examples, /b/) has an
operator on each side, the precedence table shows which operator
governs it most directly.

The two views differ, however, when the language also has unary
operators (prefix or suffix), an in particular when some unary
operators bind less tightly than some binary operators.

If our imaginary language also has a unary prefix operator Pop, which
binds less tightly than Bop or BOP, then both views agree that the
input
#+begin_example
Pop a BOP b
#+end_example
will produce Pop(BOP(a, b)).  But what about the input
#+begin_example
a BOP Pop b
#+end_example
in which the prefix operator and the binary operator are adjacent?

On the first view, there is an operator priority clash: BOP and Pop
both might govern operand /b/, and Pop is closer, but BOP binds more
tightly. Parsing this input as BOP(a, Pop(b)) would violate the rule
that unparenthesized input never produces a syntax tree with a
loose-binding operator (Pop) as a child of a tight-binding operator
(BOP).  This is the behavior of the operator-precedence parser built
into Prolog systems.

On the second view, the relative priority of the operators is not
relevant to the case.  There is only one candidate tree, and no need
to consult the precedence table in order to decide which tree to
accept.  This is the behavior observable in parsers built using yacc
and similar tools built to work like yacc.  Concretely, those parsers
use the precedence table to resolve shift/reduce conflicts.  Since
there is no shift-reduce conflict in the input "a BOP Pop b", the
positions of BOP and Pop in the precedence table are immaterial.

Concretely, Alloy accepts without demur an expression like /p and some
x : Doc | q[x]/, with an unparenthesized level-1 quantified formula as
the right operand of a level-5 conjunction.

We could attempt to model this behavior by making the right-hand side
of any binary operator allow expressions rooted in prefix unary
operators (let, all, some, ... in level 1; negation at level 6;
quantified expressions at level 8; cardinality (#) at level 11) even
if they bind less tightly.

But this change to the grammar has the unfortunate side effect that an
input of the form
#+begin_example
a BOP Pop b BOP c
#+end_example
is ambiguous between BOP(a, Pop(BOP(b, c))) and BOP(BOP(a, Pop(b)),
c).  Yacc-style parsers (and the Analyzer) will prefer the former.  An
ixml processor will simply choose one and inform the user that there
were others.

Similar considerations apply in the case of the suffix operator
box-join.  The Alloy Analyzer accepts the input "a.b[c].d", which a
strictly leveled grammar would reject.  (Such expressions do occur in
the sample models, so I would like to accept them if possible.)  For
reasons I am not sure I understand, allowing the left-hand side of the
dot-join operator to include box joins does not seem to lead to
adverse consequences.  It may possibly introduce an ambiguity; if so,
the ambiguity may be harmless.

Further investigation is needed.

** Testing

There is not currently a systematic test suite for this grammar; one
could be constructed by
- generating test cases from the grammar in the usual way, and
- running those tests against the Alloy Analyzer to establish a
  baseline set of results, then
- running those tests against the grammar given here.

In the meantime, a less thorough but useful set of test cases is given
by the set of Alloy models distributed with the Alloy Analyzer.  These
include models given in Jackson's book, a directory of examples, and a
directory of utility models.  All are intended as acceptable models, so
running them as a test set just involves parsing them all and checking
the results for /ixml:state/ attributes identifying problems.

As of noon, 25 March 2024, the models distributed with Alloy 6
produced the results shown below.  (As of the next day some of the
unexpected discrepancies have been fixed, others not.)

*** Expected discrepancies
Because of the discrepances between the language accepted by this
grammar and that accepted by the Alloy Analyzer which were discussed
at the beginning of this document, some discrepant results are
expected.

Some illustrate the issue with unparenthesized quantification in
operands of tighter-binding operators:

- ~book/chapter6/hotel4.als~ fails to parse (unparenthesized quantified
  formula within disjunction).
- ~book/chapter6/mediaAssets.als~ fails to parse (unparenthesized
  /let/-expression within conditional).
- ~book/chapter6/ringElection2.als~ fails to parse (unparenthesized
  quantified formula within conditional).

For example, model ~book/chapter6/hotel4.als~ contains the following fact:
#+begin_example
fact NoIntervening {
	all c: Checkin |
		c.post = last
		or some e: Entry {
			e.pre = c.post
			e.room = c.room
			e.guest = c.guest
		}
	}
#+end_example
Under the grammar given here, this requires parentheses around the
quantified formula over /e/: "~some e: ... c.guest~".

In ~book/chapter6/mediaAssets.als~ the issue is a /let/-expression
in the consequent-clause of a conditional.
#+begin_example
assert PasteNotAffectHidden {
	all xs, xs": ApplicationState |
		(appInv [xs] and paste [xs, xs"]) => 
			let c = xs.currentCatalog | xs".catalogState[c].hidden = xs.catalogState[c].hidden
	}
#+end_example
The others listed are similar.

Some reflect the grammar's current restriction to Alloy 4, which
does not have keywords or syntax for temporal logic:
- ~examples/temporal/buffer.als~ fails to parse (unrecognized ~var~ keyword).
- ~examples/temporal/leader.als~ fails to parse (unrecognized ~var~ keyword).
- ~examples/temporal/leader_events.als~ fails to parse (unrecognized ~var~ keyword).
- ~examples/temporal/trash.als~ fails to parse (unrecognized ~var~ keyword).

Currently, these all fail on an unrecognized ~var~ keyword.  Model
~examples/temporal/trash.als~, for example fails on line 1:
#+begin_example
var sig File {}
#+end_example
  
Two cases may reflect either an undocumented extension to the grammar, or
perhaps a relic of earlier syntactic rules.

- ~util/integer.als~ failed to parse.  The string "~fun/add~" and
  similar are apparently taken as qualified names, but "fun" is a
  reserved word, so the grammar does not accept them.

  Perhaps the prefix "~fun/~" is a signal to the Analyzer to call a
  built-in function implemented in the underlying Java?  The parse
  trees shown by the 6.0 Analyzer seem to make this plausible.  For
  the declaration "~fun plus [n1, n2: Int] : Int { n1 fun/add n2 }~",
  the parse tree shows a function body whose structure is:
  + body (Int)
    - int->int (Int)
      + @+ (Int)
        - int->int (Int)
          + variable n1 (Int)
        - int->int (Int)
          + variable n2 (Int)

  Since the construction "~fun~" + "~/~" + /name/ does not occur in
  any other model seen so far, it seems unlikely to be allowed in
  user-written models, so I don't now plan to change the gramar to
  accept it.

- ~util/ordering.als~ failed to parse.  (Tripped over "~module
  util/ordering[exactly elem]~" at "~elem~".  Added "exactly"
  to the rule for module declarations.  Now fails on a field name
  given as "pred/totalOrder".)  
 
Two cases involve what appear to be casts to "~int~".  Casts are not
present in the grammar at the moment, because they are not present in
/J/ or /G/, from which the grammar was derived.  (It looks like they
are present in /C/, but I don't find the grammatical rules of /C/ easy
to read.

- ~examples/algorithms/stable_ringlead.als~ fails to parse.  There is
  a conditional within the argument of box join.  That establishes
  pretty well that it was an error to restrict the argument to
  /expr10/.  Have changed to allow /if-then-else/ as well.

  Further parsing errors on expressions like "~int x = int y~".
  The quick guide to Alloy 4 says casting expressions must use
  brackets, so "~int[x] = int[y]~" and suggests implicitly that
  "~int x~" is Alloy 3 syntax.  That moves this to a won't-fix.

- ~util/sequniv.als~ failed to parse ("0" as numeric constant).
  Fixed.  Now fails on a call to "~int[i"]~", which the grammar
  currently does not accept because "int" is reserved.  To allow
  casting expressions of this kind, the grammar would need to
  add a rule for them.

One case involves macros -- a feature described in the documentation
but not in the grammars I'm working from.

- ~util/time.als~ fails to parse because the module uses macros,
  which are not currently part of the grammar.

Temporal keywords, casts, and macros all appear to be part of the
Alloy language and it would be nice to support them, if this grammar
were ever to be used to build general purpose Alloy tools.  But the
MLCD models don't use them, and sufficient unto the day is the evil
thereof.

*** Unexpected discrepancies (to be fixed)
This category initially had a number of members, but some of the
reasons for failure to parse or ambiguity have now been cleared up.
Others have now been classified for the moment as won't-fix
discrepancies.
  
*** Unexpected discrepancies now fixed
Others have now have been fixed.

- ~examples/case_studies/com.als~ is ambiguous.  The ambiguity appears
  to be in the definition of /name-minus-reserved-words/, between two
  different right-hand sides, namely "~'in', namechar+~" and "~'int',
  namechar+~".  I inserted the second by hand to exclude "~int~" from
  the definition of the nonterminal and failed to change the first.
- ~examples/puzzles/handshake.als~ was ambiguous.  Also /int/-related.
- ~examples/systems/views.als~ was ambiguous; the ambiguity involved
  the keyword "~this~".  Fixed by adding "~this~" to the list of non-name
  tokens.
- ~util/seqrel.als~ is ambiguous (rule for /import/ allowed trailing
  whitespace; now fixed).
  

