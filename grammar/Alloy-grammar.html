<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-26 Tue 16:22 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Alloy grammar in invisible XML</title>
<meta name="author" content="Michael Sperberg-McQueen" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Alloy grammar in invisible XML</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgff87044">0.0.1. Revision history</a></li>
<li><a href="#org335ca54">0.0.2. To do</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#notes">1. Preliminary notes</a></li>
<li><a href="#toplevel">2. Top level:  modules</a>
<ul>
<li><a href="#org6448fc3">2.1. Module declaration</a></li>
<li><a href="#orge7a3bbc">2.2. Imports</a></li>
<li><a href="#org3923301">2.3. Kinds of paragraphs</a></li>
</ul>
</li>
<li><a href="#signatures">3. Signatures</a></li>
<li><a href="#org78f9707">4. Functions and predicates</a></li>
<li><a href="#org7eda345">5. Facts and assertions</a></li>
<li><a href="#org3d0ba1c">6. Commands</a></li>
<li><a href="#org50d4d52">7. Common constructs</a>
<ul>
<li><a href="#org8d143b9">7.1. Declarations</a></li>
<li><a href="#expressions">7.2. Expressions</a>
<ul>
<li><a href="#expr01">7.2.1. <i>Let</i> expressions, quantified expressions (<i>expr01</i>)</a></li>
<li><a href="#org43c9cb9">7.2.2. Disjunctions (<i>expr02</i>)</a></li>
<li><a href="#orgcb5e418">7.2.3. Bi-implications (<i>expr03</i>)</a></li>
<li><a href="#orgec6d0e1">7.2.4. Implications (<i>expr04</i>)</a></li>
<li><a href="#org343907b">7.2.5. Conjunctions (<i>expr05</i>)</a></li>
<li><a href="#org31797e3">7.2.6. Negated expressions (<i>expr06</i>)</a></li>
<li><a href="#org19fc8d2">7.2.7. Comparisons and negated comparisons (<i>expr07</i>)</a></li>
<li><a href="#org0d7c656">7.2.8. Expression quantifiers and multiplicities (<i>expr08</i>)</a></li>
<li><a href="#orgbb1a2be">7.2.9. Bit-shifting operators (<i>expr09</i>)</a></li>
<li><a href="#org6c4241f">7.2.10. Union and difference (<i>expr10</i>)</a></li>
<li><a href="#orgba25d40">7.2.11. Cardinality (#) (<i>expr11</i>)</a></li>
<li><a href="#org68b4167">7.2.12. Override (++) (<i>expr12</i>)</a></li>
<li><a href="#org4b5871f">7.2.13. Intersection (&amp;) (<i>expr13</i>)</a></li>
<li><a href="#orgeae536f">7.2.14. Arrow product (-&gt;) (<i>expr14</i>)</a></li>
<li><a href="#org9a22cb4">7.2.15. Restriction operators (&lt;: and :&gt;) (<i>expr15</i>, <i>expr16</i>)</a></li>
<li><a href="#orgb5e2a6f">7.2.16. Box join (<i>expr17</i>)</a></li>
<li><a href="#org8f0879d">7.2.17. Dot join (<i>expr18</i>)</a></li>
<li><a href="#org412e566">7.2.18. Tightly binding unary operators (<i>expr19</i>)</a></li>
<li><a href="#org1c907f0">7.2.19. Base expressions</a></li>
</ul>
</li>
<li><a href="#org7155b8c">7.3. Blocks</a></li>
</ul>
</li>
<li><a href="#orge73df4f">8. Low-level constructs</a>
<ul>
<li><a href="#names-nums">8.1. Names and numbers</a></li>
<li><a href="#orgeb17bd9">8.2. Multiplicities and quantifiers</a></li>
<li><a href="#ops">8.3. Operators</a>
<ul>
<li><a href="#orgf7322dc">8.3.1. Unary operators</a></li>
<li><a href="#org0356621">8.3.2. Binary operators</a></li>
<li><a href="#orgb69fee5">8.3.3. Precedence</a></li>
</ul>
</li>
<li><a href="#org2e89bb1">8.4. Constants</a></li>
<li><a href="#orga37b31e">8.5. Separators</a></li>
<li><a href="#org4c04827">8.6. Whitespace</a></li>
<li><a href="#orge62aedc">8.7. Comments</a></li>
<li><a href="#orgf839529">8.8. Keywords</a></li>
</ul>
</li>
<li><a href="#org41bcde1">9. Miscellaneous</a>
<ul>
<li><a href="#org16bbe1a">9.1. Enumerations</a></li>
<li><a href="#names-minus">9.2. Avoiding ambiguity between keywords and names</a></li>
<li><a href="#BOP-POP">9.3. Operator precedence and interactions of binary and unary operators</a></li>
<li><a href="#org72dcb6d">9.4. Testing</a>
<ul>
<li><a href="#orga1e7e0d">9.4.1. Expected discrepancies</a></li>
<li><a href="#orga48c7c4">9.4.2. Unexpected discrepancies (to be fixed)</a></li>
<li><a href="#org4533c45">9.4.3. Unexpected discrepancies now fixed</a></li>
</ul>
</div>
</div>
<p>
This document gives a grammar for Alloy in invisible XML (ixml) form,
embedded in expository prose.
</p>

<p>
The reader is assumed to have some familiarity with Alloy and
context-free grammars.  Details of ixml syntax will not be explained.
</p>

<div id="outline-container-orgff87044" class="outline-4">
<h4 id="orgff87044"><span class="section-number-4">0.0.1.</span> Revision history</h4>
<div class="outline-text-4" id="text-0-0-1">
<p>
Revisions:
</p>

<ul class="org-ul">
<li>2024-03-26 : CMSMcQ : suppress a number of literals and nonterminals</li>
<li>2024-03-26 : CMSMcQ : parse MLCD models, find and fix some errors</li>
<li>2024-03-26 : CMSMcQ : resolve or accept all failures to parse
examples that ship with Alloy</li>
<li>2024-03-15 : CMSMcQ : find and fix some bugs; change some s to S.</li>
<li>2024-03-14 : CMSMcQ : better names (without reserved words)</li>
<li>2024-03-10/13 : CMSMcQ : pushing through</li>
<li>2024-03-10 : CMSMcQ : split expr into expr01 .. expr19</li>
<li>2024-03-10 : CMSMcQ : I think whitespace is dealt with.</li>
<li>2024-02-23 : CMSMcQ : move to an org file (as illustrated by NDTW).</li>
<li>2024-02-23 : CMSMcQ : resume work.</li>
<li>2021-05-06 : CMSMcQ : made ixml grammar.  Not finished.</li>
</ul>
</div>
</div>

<div id="outline-container-org335ca54" class="outline-4">
<h4 id="org335ca54"><span class="section-number-4">0.0.2.</span> To do</h4>
<div class="outline-text-4" id="text-0-0-2">
</div>
<ol class="org-ol">
<li><a id="org7c155ae"></a><span class="done DONE">DONE</span> Clean up <i>name</i> handling (again) - issue #5<br />
<div class="outline-text-5" id="text-0-0-2-1">
<p>
<a href="https://github.com/MLCD-code/Alloy-XML/issues/5">https://github.com/MLCD-code/Alloy-XML/issues/5</a>
</p>
</div>
</li>
<li><a id="org212d5cc"></a><span class="todo TODO">TODO</span> Check grammar against quick guide to Alloy 4<br />
<div class="outline-text-5" id="text-0-0-2-2">
<p>
<a href="http://alloytools.org/quickguide/">http://alloytools.org/quickguide/</a>
</p>
<ul class="org-ul">
<li>"<code>seq</code>" as reserved word</li>
<li>"<code>private</code>" as reserved word</li>
<li>meta-facility</li>
</ul>
</div>
</li>
<li><a id="org2f70282"></a>Support macros as described in quick guide?<br />
<div class="outline-text-5" id="text-0-0-2-3">
<p>
<a href="http://alloytools.org/quickguide/macro.html">http://alloytools.org/quickguide/macro.html</a>
</p>
</div>
</li>
<li><a id="orgccf53ec"></a>Support grammar of 6.0?<br />
<div class="outline-text-5" id="text-0-0-2-4">
<p>
<a href="http://alloytools.org/spec.html">http://alloytools.org/spec.html</a>
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-notes" class="outline-2">
<h2 id="notes"><span class="section-number-2">1.</span> Preliminary notes</h2>
<div class="outline-text-2" id="text-notes">
<p>
The grammar started as a fairly literal transcription from the
Alloy 4 grammar on the Alloy Tools web site, but in its current
form it is a manually constructed mixture of three grammars:
</p>

<ul class="org-ul">
<li>the grammar in Appendix B of Daniel Jackson's <i>Software abstractions</i> 2d edition.</li>
<li>the grammar at <a href="http://alloytools.org/download/alloy4-grammar.txt">http://alloytools.org/download/alloy4-grammar.txt</a>.</li>
<li>the grammar at <a href="https://github.com/AlloyTools/org.alloytools.alloy/blob/master/org.alloytools.alloy.core/parser/Alloy.cup">https://github.com/AlloyTools/org.alloytools.alloy/blob/master/org.alloytools.alloy.core/parser/Alloy.cup</a>.</li>
</ul>

<p>
In what follows, these may be referred to respectively as <i>J</i>, <i>G</i>,
and <i>C</i> (for <i>Jackson</i>, <i>grammar</i>, and <i>CUP</i> grammar).  <i>C</i> has been
consulted only for clarification of specific points; in particular,
the grammar here does not include the new keywords and constructions
which are part of the extension to temporal logic in Alloy 6.
</p>

<p>
<b>Goal(s):</b> The obvious goal for an ixml grammar of Alloy is to make a
grammar that comes as close as feasible to accepting the same language
as the Alloy 6.0 Analyzer.  A second less ambitious goal is to match
an earlier version of the language (4.0, or 5.1).  But the core goal
is to handle the subset of Alloy used in the models made by the MLCD
project; anything else is supererogatory.  We would derive a certain
amount of satisfaction from supporting the entire 6.0 language, but it
is not part of the minimum required to declare victory.
</p>

<p>
<b>Differences from <i>J</i> and <i>G</i>:</b> In the grammar given here, I have
</p>
<ul class="org-ul">
<li>rewritten the rule for expressions so that operator precedence
follows automatically from the structure of the grammar, rather
than being declared separately;</li>

<li>renamed some nonterminals in an attempt to give them more
descriptive names (which affects the readability of the grammar, but
even more so the readability of the XML produced);</li>

<li>split a number of nonterminals in order to give distinct names to
variants of the production which are notionally distinct; and</li>

<li>introduced some new nonterminals so as to give some things more
informative labels (e.g. the <i>module-arguments</i> and <i>alias</i> in an
<i>import</i>).</li>
</ul>

<p>
<b>Relations and formulas:</b> Semantically, Alloy distinguishes between
relation-valued and boolean-valued expressions (aka formulas or
constraints), but the distinction is not made in the grammar given
here. But it may be observed that the logical operators bind less
tightly than the relational operators, so at a first approximation we
can say that <i>expr01</i> through <i>expr08</i> (or at least <i>expr07</i>) are
boolean-valued, and <i>expr09</i> through <i>expr19</i> are relation-valued.
</p>

<p>
<b>Whitespace handling:</b> For the most part, we follow the basic
principle that no nonterminal except the outermost one starts or ends
with whitespace.  Some exceptions are made for common separators
(<i>slash</i>, <i>comma</i>, <i>plus</i>).
</p>

<p>
In this grammar, <i>s</i> denotes optional whitespace, <i>S</i> required
whitespace.  I've tried to use <i>S</i> whenever two alphabetic tokens can
be adjacent, because otherwise the parser will insert nonsensical
token boundaries (like parsing "<code>none</code>" as the keyword "<code>no</code>" followed
by the name "<code>ne</code>").  This has the unfortunate side effect of making
the grammar reject some modules which the Alloy parser would accept.
</p>

<p>
<b>Unit rules:</b> A unit rule in the grammar produces a parse-tree node
with a single child.  In the XML produced by an ixml processor, this
can lead to very deep trees which some readers find less easy to
navigate than shallower trees would be.  In the XML form of the
abstract syntax tree, I have where possible tried to eliminate either
the child node or the parent node; sometimes this has entailed
restructuring a production.
</p>

<p>
<b>Differences in the language accepted:</b> In consequence of some of the
grammatical differences given above, the language accepted by this
grammar deviates from that accepted by the Alloy Analyzer in some ways.
At the time this was written, the known deviations were these:
</p>
<ul class="org-ul">
<li>Whitespace will be required in some locations where the Analyzer
does not require it.</li>
<li>Parentheses will be required around <i>let</i>-expressions and quantified
formulas when they appear as operands of any other operator; the
Analyzer does not always require parentheses in these cases.</li>
</ul>
</div>
</div>

<div id="outline-container-toplevel" class="outline-2">
<h2 id="toplevel"><span class="section-number-2">2.</span> Top level:  modules</h2>
<div class="outline-text-2" id="text-toplevel">
<p>
An Alloy module consists of a series of zero or more paragraphs,
optionally preceded by a module declaration and zero or more import
statements.
</p>

<div class="org-src-container">
<pre class="src src-ixml">Alloy-module: s, (module-decl, s)?, (import++s, s)?, (paragraph++s, s)?.
</pre>
</div>

<p>
For comparison, <i>J</i> has:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">alloyModule ::= [moduleDecl] import* paragraph*
</pre>
</div>

<p>
<i>G</i> has:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">specification ::= [module] open* paragraph*
</pre>
</div>
</div>

<div id="outline-container-org6448fc3" class="outline-3">
<h3 id="org6448fc3"><span class="section-number-3">2.1.</span> Module declaration</h3>
<div class="outline-text-3" id="text-2-1">
<p>
A module declaration gives the module a name (optionally
qualified by a prepended path) and may specify a series of
signature parameters given in square brackets.
</p>

<div class="org-src-container">
<pre class="src src-ixml">-module-decl: -"module", s, module-name, (s, parameters)?.
module-name: OQName.
parameters:  -"[", s, ((EXACTLY, s)?, name)++comma, s, -"]".
</pre>
</div>

<p>
In <i>J</i>, the signature parameters are just a sequence of
comma-separated names:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">moduleDecl ::= "module" qualName  [ "[" name,+ "]" ]
</pre>
</div>
<p>
But the <i>ordering</i> utility model uses "exactly" as a modifier, which
appears to be a later elaboration of the grammar.
</p>

<p>
In <i>G</i>, by contrast, the comma-separated parameter sequence begins
with one name, followed by zero or more numbers.
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">module ::= "module" name  [ "["  ["exactly"] name  ("," ["exactly"] num)*    "]" ]
</pre>
</div>

<p>
<b>Q</b> What does "exactly" do here? <b>A</b> It specifies that the
signature bound to the parameter in the external module
should have exactly the same cardinality as the signature
named in the argument.
</p>

<p>
<i>J</i> and <i>G</i> differ in their treatment of names, in a way that needs to
be mentioned.  <i>J</i> distinguishes
</p>
<ul class="org-ul">
<li><i>name</i>, a single-token lexical symbol, and</li>
<li><i>qualName</i>, a sequence of one or more names separated with slashes,
optionally preceded by <code>this/</code>.</li>
</ul>

<p>
For its (slightly different) versions of these two, <i>G</i> uses the
nonterminals <i>ID</i> and <i>name</i>, respectively.  Also, <i>G</i> often uses the
nonterminal <i>ref</i> where <i>J</i> uses <i>name</i>: in <i>G</i>, <i>ref</i> is a name or
one of a small number of predefined identifiers (<code>univ</code>, <code>Int</code>,
<code>seq/Int</code>).
</p>

<p>
Here, the nonterminal <i>name</i> is used for a single token, and
<i>qual-name</i> is reserved for compound (qualified) names with non-empty
paths.  In context where either is possible (<i>J</i>'s <i>qualName</i> or <i>G</i>'s
<i>name</i> or <i>ref</i>), the nonterminal <i>OQName</i> ('optionally qualified
name') is used.
</p>
</div>
</div>

<div id="outline-container-orge7a3bbc" class="outline-3">
<h3 id="orge7a3bbc"><span class="section-number-3">2.2.</span> Imports</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Import statements identify modules to be imported.  If the module
being imported is parameterized, each parameter must be given a value
consisting of the qualified name of a signature.  The module can also
be given an alias.
</p>

<div class="org-src-container">
<pre class="src src-ixml">import: (private, S)?, -"open", s, OQName,
        (s, module-arguments)?,
        (s, -"as", s, alias)?.
module-arguments: "[", s, ref++comma, s, "]".
alias: -name.
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">import ::= "open"  qualName  [ "[" qualName,+ "]" ]  [ "as" name ]
</pre>
</div>


<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">open ::= ["private"]  "open"  name  [ "[" ref,+ "]" ]  [ "as" name ]
</pre>
</div>
</div>
</div>

<div id="outline-container-org3923301" class="outline-3">
<h3 id="org3923301"><span class="section-number-3">2.3.</span> Kinds of paragraphs</h3>
<div class="outline-text-3" id="text-2-3">
<div class="org-src-container">
<pre class="src src-ixml">paragraph: fact-decl | assert-decl | fun-decl | pred-decl 
         | cmd-decl | enum-decl | sig-decl.
</pre>
</div>

<p>
<i>J</i> lacks <i>enumDecl</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">paragraph ::= sigDecl | factDecl | predDecl | funDecl | assertDecl | cmdDecl 
</pre>
</div>

<p>
<i>G</i> omits <i>factDecl</i> and adds <i>enumDecl</i>.
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">paragraph ::= factDecl | assertDecl | funDecl | cmdDecl | enumDecl | sigDecl
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-signatures" class="outline-2">
<h2 id="signatures"><span class="section-number-2">3.</span> Signatures</h2>
<div class="outline-text-2" id="text-signatures">
<p>
A signature declares a set of atoms, specifies some relations in which
they participate (as the left-most member), and may optionally impose
constraints on them.
</p>

<div class="org-src-container">
<pre class="src src-ixml">sig-decl: (private, S)?, (abstract, S)?, (@mult, S)?, 
          -"sig", S, name++comma, S,
          (sig-ext, s)?,
          sig-body, 
          (s, sig-constraints)?.
sig-ext: extends; subset-of.
extends: -"extends", S, ref.
subset-of: -"in", S, ref++plus.
sig-body: -"{", s, (decl++comma, s)?, -"}".
sig-constraints: -block.
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">sigDecl ::= ["abstract"] [mult] "sig" name,+ [sigExt] "{" decl,* "}" [block]
sigExt ::= "extends" qualName | "in" qualName ["+" qualName]*
</pre>
</div>

<p>
<i>G</i> adds a <code>private</code> keyword (and allows repeated keywords):
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">sigDecl ::= sigQual* "sig" name,+ [sigExt] "{" decl,* "}" [block]
sigQual ::= "abstract" | "lone" | "one" | "some" | "private"
sigExt ::= "extends" ref
sigExt ::= "in" ref ["+" ref]*
</pre>
</div>
</div>
</div>

<div id="outline-container-org78f9707" class="outline-2">
<h2 id="org78f9707"><span class="section-number-2">4.</span> Functions and predicates</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">
<pre class="src src-ixml">fun-decl: (private, S)?, 
          -"fun", S, (ref, ".")?, name, s, (args, s)?, ":", s, 
          expr, s, block.
pred-decl: (private, S)?, 
           -"pred", S, (ref, ".")?, name, s, (args, s)?, block.
args:  -"(", s, decl**comma, s, -")"
    |  -"[", s, decl**comma, s, -"]".
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">funDecl ::= "fun" [qualName "."] name [paraDecls] ":" expr "{" expr "}"
predDecl ::= "pred" [qualName "."] name [paraDecls] block
paraDecls ::= "(" decl,* ")" | "[" decl,* "]"
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">funDecl ::= ["private"] "fun" [ref "."] name "(" decl,* ")" ":" expr block
funDecl ::= ["private"] "fun" [ref "."] name "[" decl,* "]" ":" expr block
funDecl ::= ["private"] "fun" [ref "."] name                ":" expr block

funDecl ::= ["private"] "pred" [ref "."] name "(" decl,* ")" block
funDecl ::= ["private"] "pred" [ref "."] name "[" decl,* "]" block
funDecl ::= ["private"] "pred" [ref "."] name                block
</pre>
</div>
</div>
</div>

<div id="outline-container-org7eda345" class="outline-2">
<h2 id="org7eda345"><span class="section-number-2">5.</span> Facts and assertions</h2>
<div class="outline-text-2" id="text-5">
<p>
Facts and assertions are statements about the universe.
Assertions may or may not be true; facts are true by fiat.
</p>
<div class="org-src-container">
<pre class="src src-ixml">fact-decl: -"fact", S, (name, s)?, block.
assert-decl: -"assert", S, (name, s)?, block.
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">factDecl ::= "fact" [name] block
assertDecl ::= "assert" [name] block
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">factDecl ::= "fact" [name] block
assertDecl ::= "assert" [name] block
</pre>
</div>
</div>
</div>

<div id="outline-container-org3d0ba1c" class="outline-2">
<h2 id="org3d0ba1c"><span class="section-number-2">6.</span> Commands</h2>
<div class="outline-text-2" id="text-6">
<p>
Commands are instructions to the Alloy Analyser to check certain
states of affairs within instances with a given maximum size (scope):
seek instances of a predicate, seek counter-examples to an assertion.
</p>

<div class="org-src-container">
<pre class="src src-ixml">cmd-decl: (@name, s, -":", s)?, @verb, S, (name|block), (S, scope)?.
verb: "run"|"check".
scope: expectation
       | typescopes.
typescopes: -"for", S, numbers, (S, expectation)?.
-numbers: number, (s, exceptions)?
       | typescope++comma.
expectation:  -"expect", s, ("0" | "1").
typescope: exact-scope; max-scope.
exact-scope: -EXACTLY, s, -max-scope.
max-scope: number, s, (OQName|"int"|"Int"|"seq").
exceptions: "but", s, typescope++comma.
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">cmdDecl ::= [name ":"] ["run"|"check"] [qualName|block] [scope]
scope ::= "for" number ["but" typescope,+] | "for" typescope,+
typescope ::= ["exactly"] number qualName
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">cmdDecl ::= [name ":"] ("run"|"check") (name|block) scope
scope ::= "for" number                   ["expect" (0|1)]
scope ::= "for" number "but" typescope,+ ["expect" (0|1)]
scope ::= "for"              typescope,+ ["expect" (0|1)]
scope ::=                                ["expect" (0|1)]
typescope ::= ["exactly"] number [name|"int"|"seq"]
</pre>
</div>
<p>
<i>G</i>'s definition of <i>typescope</i> introduces an ambiguity;
I'm going to go with <i>J</i>, which requires an identifier of
some kind.
</p>
</div>
</div>
<div id="outline-container-org50d4d52" class="outline-2">
<h2 id="org50d4d52"><span class="section-number-2">7.</span> Common constructs</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-org8d143b9" class="outline-3">
<h3 id="org8d143b9"><span class="section-number-3">7.1.</span> Declarations</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Declarations are used in many places, so I've given them their
own section here rather than putting them with just one of
their possible contexts.
</p>

<div class="org-src-container">
<pre class="src src-ixml">decl: (private, s)?, (disj, S)?, variable++comma, s, -":", s, bounds.
disj: -"disj".
variable: -name.
bounds: (disj, S)?, expr.
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">decl ::= ["disj"] name,+ ":" ["disj"] expr
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">decl ::= ["private"] ["disj"] name,+ ":" ["disj"] expr
</pre>
</div>
</div>
</div>

<div id="outline-container-expressions" class="outline-3">
<h3 id="expressions"><span class="section-number-3">7.2.</span> Expressions</h3>
<div class="outline-text-3" id="text-expressions">
<p>
Like many grammars involving multiple operators, both <i>J</i> and <i>G</i> use
a single highly ambiguous production rule for expressions (<i>expr</i>),
and provide an operator precedence table to clarify which parse trees
should be accepted and which should be discarded.  See <a href="#ops">section on
Operators</a> below.
</p>

<p>
This is the definition of <i>expr</i> in <i>J</i>:
</p>

<div class="org-src-container">
<pre class="src src-Jebnf">expr ::= const 
   | qualName 
   | "@" name 
   | "this"
   | unOp expr 
   | expr binOp expr 
   | expr arrowOp expr
   | expr "[" expr,* "]"
   | expr ["!"|"not"] compareOp expr
   | expr ("=&gt;"|"implies") expr "else" expr
   | "let" letDecl,+ blockOrBar
   | quant    decl,+ blockOrBar
   | "{" decl,+ blockOrBar "}"
   | "(" expr ")" 
   | block
</pre>
</div>

<p>
<i>G</i> is largely the same but differs ih some details:
</p>
<ul class="org-ul">
<li>It inlines <i>const</i>.</li>
<li>It merges <code>qualName | "@" name</code>.</li>
<li>It does not single out <code>this</code>, treating it instead as a <i>name</i>.</li>
<li>It adds <code>Int</code> and <code>seq/Int</code>.</li>
</ul>

<div class="org-src-container">
<pre class="src src-ebnf">expr ::= "let" letDecl,+ blockOrBar
       | quant decl,+    blockOrBar
       | unOp expr
       | expr binOp   expr
       | expr arrowOp expr
       | expr ["!"|"not"] compareOp expr
       | expr ("=&gt;"|"implies") expr "else" expr
       | expr "[" expr,* "]"
       |     number
       | "-" number
       | "none"
       | "iden"
       | "univ"
       | "Int"
       | "seq/Int"
       | "(" expr ")"
       | ["@"] name
       | block
       | "{" decl,+ blockOrBar "}"
</pre>
</div>

<p>
Because ixml makes no use of precedence tables, we need to re-express
operator precedence in the structure of the grammar.  We will do this
by factoring <i>expr</i> into several flavors, which we name <i>expr01</i>,
<i>expr02</i>, etc., each defining expressions involving operators at one
precedence level.
</p>

<p>
In their pure form, the levels look something like this:
</p>

<ul class="org-ul">
<li>1: let-expr:  "let", s, let-decl++comma, s, block-or-bar.</li>
<li>1: all-ex01:  "all",  s, decl++comma, s, block-or-bar.
<i>(And similarly for <code>no</code>, <code>some</code>, <code>lone</code>, <code>one</code>, <code>sum</code>.)</i></li>
<li>2: disjunction:  expr02, s, ("||"; "or"), s, expr03.</li>
<li>3: bi-implication:  expr03, s, ("&lt;=&gt;"; "iff"), s, expr04.</li>
<li>4: if-then:  expr05, s, ("=&gt;"; "implies"), s, expr04.</li>
<li>4 bis: if-then-else: expr05, s, ("=&gt;"; "implies"), s, expr04-bis, s, "else", s, expr04.</li>
<li>5: conjunction:  expr05, s, ("&amp;&amp;"; "and"), s, expr06.</li>
<li>6: negation:  NOT, s, expr06.</li>
<li>7: in:  expr07, s, "in", s, expr08.
<i>(And so also for <code>eq</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, <code>gt</code>, <code>not-in</code>, etc.)</i></li>
<li>8: quantified-expression: QUANT, s, expr07.
<i>(For QUANT in: <code>no</code>, <code>some</code>, <code>lone</code>, <code>one</code>, <code>set</code>, <code>seq</code>.)</i></li>
<li>9: bit-shift: expr09, s, ("<a id="org7acb944"></a>"; "&gt;&gt;&gt;"), s, expr10.</li>
<li>10: union, difference: expr10, s, ["+-"], s, expr11.</li>
<li>11: cardinality: "#", s, expr12.</li>
<li>12: override: base-12, s, "++", s, overlay-13.</li>
<li>13: intersection:  expr13, s, "&amp;", s, expr14.</li>
<li>14: arrow-expr: expr14, s, (left-mult, s)?, -"-&gt;", s, (right-mult, s)?, expr15.</li>
<li>15: left-restriction: lr-set-15, s, "&lt;:", s, lr-rel-16.</li>
<li>16: right-restriction: rr-rel-16, s, ":&gt;", s, rr-set-17.</li>
<li>17: box-join:  expr17, "[", s, (selector-10 ++ comma, s)?, "]".</li>
<li>18: dot-join: expr18, s, ".", s, expr19.</li>
<li>19: inverse, closure: ["~<sup>*</sup>"], s, expr20.</li>
<li>20: base expressions:  names, numbers, (&#x2026;), {&#x2026;}.</li>
</ul>

<p>
Note at level 17 that box-join is syntactically the same as function
application.  The choice of level-10 expressions for <i>selector</i> is a
guess: in box-join (as in dot-join), selectors denote relations, so
formulas like those at levels 1-6 and values like those at levels 7-9
seem implausible.  If we ever need needing logical expressions as
function arguments, we'll need parentheses.  (Or maybe we should just
use <i>expr</i>.)
</p>

<p>
This multi-leveled definition of <i>expr</i> comes close to describing the
sentences accepted by the Alloy Analyzer and producing appropriate
trees, but there are some cases where this grammar requires
parentheses in inputs accepts without parentheses by the Analyzer; see
the discussion of <a href="#BOP-POP">unary and binary operators and their interaction</a>
below.
</p>
</div>

<div id="outline-container-expr01" class="outline-4">
<h4 id="expr01"><span class="section-number-4">7.2.1.</span> <i>Let</i> expressions, quantified expressions (<i>expr01</i>)</h4>
<div class="outline-text-4" id="text-expr01">
<div class="org-src-container">
<pre class="src src-ixml">-expr: expr01.

{ expr01:  Weakest binding:  let, quantified statements }
-expr01: let-expr;
         all-ex01; none-ex01; some-ex01; lone-ex01; one-ex01; sum-ex01; 
         expr02.

let-expr:  -"let", s, let-decl++comma, s, block-or-bar.
let-decl: variable, s, "=", s, value.
value: expr.

{ quantified expressions }
all-ex01:  -"all",  S, decl++comma, s, block-or-bar.
none-ex01: -"no",   S, decl++comma, s, block-or-bar.
some-ex01: -"some", S, decl++comma, s, block-or-bar.
lone-ex01: -"lone", S, decl++comma, s, block-or-bar.
one-ex01:  -"one",  S, decl++comma, s, block-or-bar.
sum-ex01:  -"sum",  S, decl++comma, s, block-or-bar.
</pre>
</div>

<p>
For now <i>block-or-bar</i> is defined as containg <i>expr</i>.  I think that that
may be all right, but it has not been tested.
</p>

<p>
In both <i>J</i> and <i>G</i>, <code>let</code> expressions are defined thus:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">expr ::= "let" letDecl,+ blockOrBar.
letDecl ::= name "=" expr
</pre>
</div>

<p>
The various quantified expressions are instances of a single pattern:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= quant decl,+    blockOrBar.
</pre>
</div>
</div>
</div>

<div id="outline-container-org43c9cb9" class="outline-4">
<h4 id="org43c9cb9"><span class="section-number-4">7.2.2.</span> Disjunctions (<i>expr02</i>)</h4>
<div class="outline-text-4" id="text-7-2-2">
<div class="org-src-container">
<pre class="src src-ixml">{ expr02:  disjunctions }
-expr02:  disjunction; expr03.
disjunction:  expr02, OR, expr03.
OR: s, -"||", s; S, -"or", S.
</pre>
</div>

<p>
In <i>J</i> and <i>G</i>, disjunctions are the first of many instances of
the pattern shown for all binary operators:
</p>

<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= expr binOp expr.  
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb5e418" class="outline-4">
<h4 id="orgcb5e418"><span class="section-number-4">7.2.3.</span> Bi-implications (<i>expr03</i>)</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
Bi-implication is another binary operator.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ expr03:  bi-implication }
-expr03:  bi-implication; expr04.
bi-implication:  expr03, IFF, expr04.
IFF: s, -"&lt;=&gt;", s; S, -"iff", S.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgec6d0e1" class="outline-4">
<h4 id="orgec6d0e1"><span class="section-number-4">7.2.4.</span> Implications (<i>expr04</i>)</h4>
<div class="outline-text-4" id="text-7-2-4">
<p>
Conditionals / implications are right-associative:  an embedded
implication can appear within either sub-clause.
</p>

<p>
Note that implications may be formulas or just expressions.
A first cut would be:
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ expr04:  implication -- dummy first cut }
-expr04:  implication; expr05.
implication:  expr04, s, 
              ("=&gt;"; "implies"), s, expr04, s, 
              "else", s, expr04.
</pre>
</div>

<p>
<i>J</i> and <i>G</i> give the form thus:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= expr ("=&gt;"|"implies") expr "else" expr.
</pre>
</div>

<p>
Note that this production makes the <code>else</code> clause obligatory,
although the informal example on p. 69 of the book lacks a
trailing <code>else</code>.
</p>

<p>
If trailing <code>else</code> is really optional, then the then-clause should
be rewrittten here to refer to <i>expr05</i> not <i>expr04</i>.  Otherwise
we end up with the classic dangling-else problem of Algol 60.
</p>

<p>
[Later.  Hmmm.]  We seem to have an issue.  Since "=&gt;" is included in
the definition of <i>binOp</i> in <i>J</i> and <i>G</i>, the expression "<code>A =&gt; B</code>" is
clearly grammatical.  In addition, page 263 says "So, for example, <i>p
=&gt; q =&gt; r</i> is parsed as <i>p =&gt; (q =&gt; r)</i>", and "In an implication, an
else-clause is associated with its closest then-clause."
</p>

<p>
Can we enforce the nearest-then-clause rule grammatically?
</p>

<p>
Consider the simple case "if a then if b then c else d".  The rule
says we want the parse tree for this case to be
<img src="images/ifthenelse-1.dot.png" alt="ifthenelse-1.dot.png" />
and not
<img src="images/ifthenelse-2.dot.png" alt="ifthenelse-2.dot.png" />
</p>

<p>
The diagrams distinguish <i>if-then</i> expressions from <i>if-then-else</i>
expressions, and the rule appears to amount to saying that an <i>if-then</i>
expression is not allowed in the <i>then</i>-clause of an <i>if-then-else</i>
expression.  To be painfully explicit:
</p>

<ul class="org-ul">
<li>In the <i>then</i>-clause of an <i>if-then</i>:
<ul class="org-ul">
<li><i>if-then</i> is OK.</li>
<li><i>if-then-else</i> is OK.</li>
</ul></li>
<li>In the <i>then</i>-clause of an <i>if-then-else</i>:
<ul class="org-ul">
<li><i>if-then</i> is not OK.</li>
<li><i>if-then-else</i> is OK.</li>
</ul></li>
</ul>

<p>
Or in tabular form:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Parent: if-then</th>
<th scope="col" class="org-left">Parent: if-then-else</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Child: if-then</td>
<td class="org-left">OK</td>
<td class="org-left">not OK</td>
</tr>

<tr>
<td class="org-left">Child: if-then-else</td>
<td class="org-left">OK</td>
<td class="org-left">OK</td>
</tr>
</tbody>
</table>

<p>
We can, I think, express this by subdividing <i>expr04</i> into two
levels of precedence.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ expr04:  implication }
-expr04:  if-then; expr04-bis.
-expr04-bis: if-then-else; expr05.
if-then:  condition, IMPLIES, consequent.
if-then-else:  condition, 
               IMPLIES, 
               then-clause, S, 
               else-clause.
IMPLIES: s, -"=&gt;", s; S, -"implies", S.
condition: expr05.
consequent: expr04.
then-clause: expr04-bis.
else-clause: -"else", S, expr04.
</pre>
</div>
<p>
We give the then-clause two different names in order to
capture the required difference in allowed content.
</p>
</div>
</div>

<div id="outline-container-org343907b" class="outline-4">
<h4 id="org343907b"><span class="section-number-4">7.2.5.</span> Conjunctions (<i>expr05</i>)</h4>
<div class="outline-text-4" id="text-7-2-5">
<div class="org-src-container">
<pre class="src src-ixml">{ expr05:  conjunction }
-expr05:  conjunction; expr06.
conjunction:  expr05, AND, expr06.
AND: s, "&amp;&amp;", s; S, "and", S.
</pre>
</div>
</div>
</div>

<div id="outline-container-org31797e3" class="outline-4">
<h4 id="org31797e3"><span class="section-number-4">7.2.6.</span> Negated expressions (<i>expr06</i>)</h4>
<div class="outline-text-4" id="text-7-2-6">
<p>
Jackson appears not to say explicitly that negation is
right-associative, but it cannot be left-associative
and I think it's probably a bad idea to try to say that
a double negation requires parentheses. 
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ expr06:  negated expressions }
-expr06:  negation; expr07.
negation:  NOT, expr06.
NOT: "!", s; "not", S.
</pre>
</div>

<p>
In <i>J</i> and <i>G</i>, negation is just an instance of <i>unOp</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= unOp expr.
</pre>
</div>
</div>
</div>

<div id="outline-container-org19fc8d2" class="outline-4">
<h4 id="org19fc8d2"><span class="section-number-4">7.2.7.</span> Comparisons and negated comparisons (<i>expr07</i>)</h4>
<div class="outline-text-4" id="text-7-2-7">
<p>
Since Alloy allows negation symbols both on the overall comparison
(e.g. "<code>not x &lt; y</code>") and on the comparison operator (e.g. "<code>x not &lt; y</code>"),
comparisons and their negations are a little more complex than
other binary operators.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ expr07: comparisons } 
-expr07:  comparison; expr08.
-comparison: in; eq; lt; gt; le; ge;
             not-in; not-eq; not-lt; not-gt; not-le; not-ge.
in:  expr07, S, -"in", S, expr08.
eq:  expr07, s, -"=",  s, expr08.
lt:  expr07, s, -"&lt;",  s, expr08.
gt:  expr07, s, -"&gt;",  s, expr08.
le:  expr07, s, -"=&lt;", s, expr08.
ge:  expr07, s, -"&gt;=", s, expr08.
not-in:  expr07, S, NOT, -"in", S, expr08.
not-eq:  expr07, s, NOT, -"=",  s, expr08.
not-lt:  expr07, s, NOT, -"&lt;",  s, expr08.
not-gt:  expr07, s, NOT, -"&gt;",  s, expr08.
not-le:  expr07, s, NOT, -"=&lt;", s, expr08.
not-ge:  expr07, s, NOT, -"&gt;=", s, expr08.
</pre>
</div>

<p>
<i>J</i> and <i>G</i> have:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= expr ["!"|"not"] compareOp expr.
</pre>
</div>
</div>
</div>
<div id="outline-container-org0d7c656" class="outline-4">
<h4 id="org0d7c656"><span class="section-number-4">7.2.8.</span> Expression quantifiers and multiplicities (<i>expr08</i>)</h4>
<div class="outline-text-4" id="text-7-2-8">
<p>
Quantifiers may be used not only on formulas (see <a href="#expr01">above</a>)
but also on expressions.  Here, the quantifiers are classed
as unary operators.
</p>

<div class="org-src-container">
<pre class="src src-ixml">-expr08: quantified-expression; 
         expr09.
-quantified-expression: no-ex08; some-ex08; lone-ex08; one-ex08; 
         set-ex08; seq-ex08.
no-ex08: -"no", S, expr09.
some-ex08: -"some", S, expr09.
lone-ex08: -"lone", S, expr09.
one-ex08: -"one", S, expr09. 
set-ex08: -"set", S, member-type.
-member-type: expr09.
seq-ex08: -"seq", S, expr09.
</pre>
</div>

<p>
The names chosen are awkward; it is hoped that some experimentation
and examination of examples will suggest better names which convey
more information about the difference between the expressions
dominated by quantifiers at levels <i>expr01</i> and <i>expr08</i>.  For now,
the awkwardness is partly intentional: to underscore my current
imperfect understanding.
</p>

<p>
For comparison, expressions dominated by unary operators are defined
as follows in <i>J</i> and <i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">expr ::= unOp expr.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb1a2be" class="outline-4">
<h4 id="orgbb1a2be"><span class="section-number-4">7.2.9.</span> Bit-shifting operators (<i>expr09</i>)</h4>
<div class="outline-text-4" id="text-7-2-9">
<p>
The grammar file defines operators "<a id="orgad15f4d"></a>", and "&gt;&gt;&gt;" at precedence
level 9.  These are not documented in Jackson's bookÂ¸but in the
<a href="http://alloytools.org/quickguide/a4.html">supplementary documentation of Alloy 4</a> on the Alloy Tools web site, they are
identified as left shift ("<code>&lt;&lt;</code>"), sign-extended right shift ("<code>&gt;&gt;</code>"),
and zero-extended right shift ("<code>&gt;&gt;&gt;</code>").  The Alloy.cup grammar of
Alloy 6 assigns them the names SHL, SHA, and SHR, respectively.
Both operands should be <i>int</i> values.
</p>

<p>
<i>G</i> defines them as binary operators, so we'll follow the usual
pattern for them.
</p>

<div class="org-src-container">
<pre class="src src-ixml">-expr09: SHL-expr; SHR-expr; SHA-expr; expr10.
SHL-expr: expr09, s, "&lt;&lt;", s, expr10.
SHR-expr: expr09, s, "&gt;&gt;&gt;", s, expr10.
SHA-expr: expr09, s, "&gt;&gt;", s, expr10.
</pre>
</div>
</div>
</div>

<div id="outline-container-org6c4241f" class="outline-4">
<h4 id="org6c4241f"><span class="section-number-4">7.2.10.</span> Union and difference (<i>expr10</i>)</h4>
<div class="outline-text-4" id="text-7-2-10">
<div class="org-src-container">
<pre class="src src-ixml">-expr10:  union; set-diff; expr11.
union: expr10, s, "+", s, expr11.
set-diff: expr10, s, "-", careful-ws, expr11.
</pre>
</div>

<p>
Note that whitespace is required after the 
</p>
</div>
</div>

<div id="outline-container-orgba25d40" class="outline-4">
<h4 id="orgba25d40"><span class="section-number-4">7.2.11.</span> Cardinality (#) (<i>expr11</i>)</h4>
<div class="outline-text-4" id="text-7-2-11">
<div class="org-src-container">
<pre class="src src-ixml">-expr11:  cardinality; expr12.
cardinality: "#", s, expr12.
</pre>
</div>
</div>
</div>

<div id="outline-container-org68b4167" class="outline-4">
<h4 id="org68b4167"><span class="section-number-4">7.2.12.</span> Override (++) (<i>expr12</i>)</h4>
<div class="outline-text-4" id="text-7-2-12">
<p>
To try to guide later readers, we give distinct
names to the two operands of "<code>++</code>".  The left-hand
operand is the <i>base</i> relation, the right-hand operand
is the <i>overlay</i>. 
</p>
<div class="org-src-container">
<pre class="src src-ixml">-expr12: override; expr13.
override: base, s, "++", s, overlay.
base: expr12.
overlay: expr13.
</pre>
</div>
</div>
</div>

<div id="outline-container-org4b5871f" class="outline-4">
<h4 id="org4b5871f"><span class="section-number-4">7.2.13.</span> Intersection (&amp;) (<i>expr13</i>)</h4>
<div class="outline-text-4" id="text-7-2-13">
<div class="org-src-container">
<pre class="src src-ixml">-expr13:  intersection; expr14.
intersection:  expr13, s, "&amp;", s, expr14.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgeae536f" class="outline-4">
<h4 id="orgeae536f"><span class="section-number-4">7.2.14.</span> Arrow product (-&gt;) (<i>expr14</i>)</h4>
<div class="outline-text-4" id="text-7-2-14">
<p>
Arrow operators are used to define relations.  They get
a little complex because they can specify multiplicity
on each side of the operator.
</p>
<div class="org-src-container">
<pre class="src src-ixml">-expr14: arrow-expr; expr15.
arrow-expr: expr14, (S, left-mult)?, s, -"-&gt;", s, (right-mult, S)?, expr15.
left-mult:  -mult; "set".
right-mult:  -mult; "set".
</pre>
</div>

<p>
<i>J</i> and <i>G</i> have:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= expr arrowOp expr.
</pre>
</div>
</div>
</div>
<div id="outline-container-org9a22cb4" class="outline-4">
<h4 id="org9a22cb4"><span class="section-number-4">7.2.15.</span> Restriction operators (&lt;: and :&gt;) (<i>expr15</i>, <i>expr16</i>)</h4>
<div class="outline-text-4" id="text-7-2-15">
<p>
Out of blind faith in generality, I follow Jackson's statement that
binary operators are left-associative, although anyone who has an
intuitive notion that one parse tree for an expression like "<code>a :&gt; b
&lt;: c &lt;: d</code>" is distinctly more natural than any other is apparently
possessed of an intuition quite unlike mine.  (For one thing, one
argument should be a relation and the other a set, that is a singleton
relation.)  It would surprise me if any restriction operator found in
the wild immediately dominated any other restriction operator, and
still more if a human wrote such an expression without using
parentheses.  But I've been surprised before.  So by all means, each
of these is left-associative.
</p>

<p>
Thinking about this, I remind myself that I often have to look the
restriction operators up when I want to use them, because I forget
which way they point.  So for both left- and right-restriction, I'm
going to name the operands as a set or a rel[ation].
</p>
<div class="org-src-container">
<pre class="src src-ixml">-expr15: left-restriction; expr16.
-expr16: right-restriction; expr17.
left-restriction: lr-set, s, "&lt;:", s, lr-rel.
right-restriction: rr-rel, s, ":&gt;", s, rr-set.
lr-set: expr15.
lr-rel: expr16.
rr-rel: expr16.
rr-set: expr17.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5e2a6f" class="outline-4">
<h4 id="orgb5e2a6f"><span class="section-number-4">7.2.16.</span> Box join (<i>expr17</i>)</h4>
<div class="outline-text-4" id="text-7-2-16">
<p>
It is not clear what kind of expressions should be allowed within the
box.  I've put <i>expr10</i> on the theory that they will normally be
relation-valued, and added <i>if-then-else</i> because I have observed
that they can be (and are in some examples) relation-valued conditionals.
White space is allowed before the left square
bracket, because the examples show it being used.
</p>
<div class="org-src-container">
<pre class="src src-ixml">-expr17: box-join; expr18.
box-join: box-left, s, -"[", s, (selector ++ comma, s)?, -"]".
box-left: expr17; sum; integer-cast.
selector: expr10; if-then-else.
sum: -"sum".
integer-cast: -"int".
</pre>
</div>

<p>
<i>J</i> and <i>G</i> have:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">expr ::= expr "[" expr,* "]".
</pre>
</div>

<p>
It should be noted that box join is syntactically identical
to function or predicate application.  Some discussion may be
helpful, since the relation may not be intuitively obvious.
Functions are treated in Alloy as relations (following the model
of Z), so a function declared
</p>
<div class="org-src-container">
<pre class="src src-Alloy">fun f [x : A] : B { ... }
</pre>
</div>
<p>
is effectively a set of (<i>A</i>, <i>B</i>) pairs.  The expression <code>f[a]</code>
is defined as equivalent to <code>a.f</code>, and returns the atoms in set <i>B</i>
which are the images of <code>a</code> in the functional relation <i>f</i>.
</p>

<p>
If the function has more than one argument, its name denotes a
relation of appropriate arity.  Suppose <i>f</i> has the signature <i>A</i> Ã
<i>B</i> Ã <i>C</i> Ã <i>D</i>, and <code>a</code>, <code>b</code>, <code>c</code> are atoms in sets <i>A</i>, <i>B</i>, <i>C</i>
respectively.  The expression <code>f[a,b,c]</code> is equivalent (see p. 279) to
<code>f[a][b][c]</code> and thus to <code>(a.f)[b][c]</code>, <code>(b.(a.f))[c]</code>,
<code>(c.(b.(a.f))</code>.  The type of <i>f</i> is <i>A</i> Ã <i>B</i> Ã <i>C</i> Ã <i>D</i>, so the type
of <code>a.f</code> is <i>B</i> Ã <i>C</i> Ã <i>D</i>, the type of <code>b.(a.f)</code> is <i>C</i> Ã <i>D</i>, and
the type of the entire expression is <i>D</i>.
</p>

<p>
Predicates could perhaps be regarded as a tuple formed from the
arguments with an added Boolean value at the end, but since Alloy does
not have a Boolean type, that view is necessrily metalinguistic and
cannot be expressed in Alloy.  
</p>
</div>
</div>

<div id="outline-container-org8f0879d" class="outline-4">
<h4 id="org8f0879d"><span class="section-number-4">7.2.17.</span> Dot join (<i>expr18</i>)</h4>
<div class="outline-text-4" id="text-7-2-17">
<div class="org-src-container">
<pre class="src src-ixml">-expr18: dot-join; expr19.
dot-join: expr17, s, ".", s, expr19.
</pre>
</div>

<p>
Note that we define <i>dot-join</i> as accepting <i>expr17</i> on its
left side, in order to allow box-join in the left operand.
(In chapter 6, the assertion <i>PasteNotAffectHidden</i> [p. 213]
includes the subexpression <code>xs'.catalogState[c].hidden</code>,
which in context.)
</p>
</div>
</div>
<div id="outline-container-org412e566" class="outline-4">
<h4 id="org412e566"><span class="section-number-4">7.2.18.</span> Tightly binding unary operators (<i>expr19</i>)</h4>
<div class="outline-text-4" id="text-7-2-18">
<p>
It's not completely clear whether Alloy 4 intends these three unary
operators to be right-associative or non-associative.  The Alloy 6
CUP grammar declares them non-associative, so that's how they were
initially defined here.
</p>

<p>
But the sample model in <code>examples/algorithms/opt_spantree.als</code>
includes the expression <code>Process in Root.*~(s.parent)</code>, where they
are clearly meant to be right-associative.
</p>
<div class="org-src-container">
<pre class="src src-ixml">-expr19: inverse; t-closure; rt-closure; expr20.
inverse: "~", s, expr19.
t-closure: "^", s, expr19.
rt-closure: "*", s, expr19.
</pre>
</div>
</div>
</div>

<div id="outline-container-org1c907f0" class="outline-4">
<h4 id="org1c907f0"><span class="section-number-4">7.2.19.</span> Base expressions</h4>
<div class="outline-text-4" id="text-7-2-19">
<p>
There are several forms of expression which contain no operators; we
define them here.
</p>

<div class="org-src-container">
<pre class="src src-ixml">-expr20:  OQName;
          "@", s, name;
          THIS;
          NONE; IDEN; UNIV; { named sets, parse as name }
          INT; SEQINT; 
          number; 
          negative-number;
          -"(", s, expr, s, -")";
          declarations-block;
          block.
negative-number: "-", -number.
declarations-block: -"{", s, 
                    decl ++ comma, s, 
                    block-or-bar, s, -"}";
</pre>
</div>

<p>
The keywords "none", "iden", "univ", "Int", and "seq/Int" are
predefined names denoting the empty set, the identity relation, the
universal set, and so on.  If we include them in the ixml grammar, any
module that uses any of them will be ambiguous, since they can all be
parsed as <i>OQName</i>, and ixml does not have any mechanism for saying to
prefer the keyword parse over the other.  So we omit them and tell the
user of the XML to watch out for <code>&lt;name&gt;univ&lt;/name&gt;</code> and the like, and
handle it appropriately.
</p>
</div>
</div>
</div>


<div id="outline-container-org7155b8c" class="outline-3">
<h3 id="org7155b8c"><span class="section-number-3">7.3.</span> Blocks</h3>
<div class="outline-text-3" id="text-7-3">
<p>
A block is just a sequence of expressions enclosed in braces; in some
contexts, the braces will determine the scope of some relevant
declaration.
</p>

<p>
In several constructs, a declaration is separated from the expression
it governs by a vertical bar.  If the declaration should govern
multiple expressions, the bar and expression can be replaced by a
brace-delimited block.  That idiom is expressed in the grammar by the
nonterminal <i>block-or-bar</i>.
</p>

<div class="org-src-container">
<pre class="src src-ixml">block: -"{", s, (expr++S, s)?, -"}".
block-or-bar: block;
              -"|", s, expr.
</pre>
</div>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">block ::= "{" expr* "}"
blockOrBar ::= block | bar expr
bar ::= "|"
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">block ::= "{" expr* "}"
blockOrBar ::= block
blockOrBar ::= "|" expr
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-orge73df4f" class="outline-2">
<h2 id="orge73df4f"><span class="section-number-2">8.</span> Low-level constructs</h2>
<div class="outline-text-2" id="text-8">
</div>
<div id="outline-container-names-nums" class="outline-3">
<h3 id="names-nums"><span class="section-number-3">8.1.</span> Names and numbers</h3>
<div class="outline-text-3" id="text-names-nums">
<p>
Note: Grammar <i>G</i> uses <i>name</i> and <i>ID</i> where grammar <i>J</i> 
uses <i>qualName</i> and <i>name</i>.  Since I want a bare name when possible, a
wrapped name sequence where necessary, I use <i>OQName</i> (i.e. optionally
qualified name) where B has <i>qualName</i>.  So we should have
</p>

<ul class="org-ul">
<li><i>OQName</i> matches either a <i>qualName</i> or a <i>name</i>.  The nonterminal
is never serialized.</li>
<li><i>qualName</i> matches a name with a non-empty qualifier.</li>
<li><i>name</i> matches an unqualified identifier.</li>
</ul>

<p>
The nonterminals <i>qualName</i> and <i>name</i> are typically serialized,
unless a more informative nonterminal name is provided.
</p>

<div class="org-src-container">
<pre class="src src-ixml">ref: OQName | UNIV | INT | SEQINT.

-OQName:  qual-name; name.

{ qualName: ("this", "/")?, name++slash. }
{ qual-name: THIS, "/", name++slash
           | name, "/", name++slash. }
qual-name: THIS, -"/", (qual, -"/")*, name
         | (qual, -"/")+, name.
{ qual: ID. }
qual: -name-minus-reserved-words.

number: '0'; ['1'-'9'], digit*.
-digit: ['0'-'9'].

-ID: letter, (letter; digit; '_'; sq; dq)*.
-letter: ['a'-'z'; 'A'-'Z'].
-sq: "'" { single quote ' }.
-dq: '"' { double quote " }.
</pre>
</div>

<p>
For reasons which will become clear later, we want the definition of
<i>name</i> in a separate code block.
</p>

<p>
It would be simple to define <i>name</i> as just an <i>ID</i>, but that does not
work.
</p>
<div class="org-src-container">
<pre class="src src-ixml">name: ID.
</pre>
</div>

<p>
<i>J</i> uses <i>qualName</i> where we have <i>OQName</i>, and treats <i>name</i> as a
primitive lexical token.
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">qualName ::= ["this/" ] (name "/")* name
</pre>
</div>

<p>
<i>G</i>, on the other hand, uses <i>name</i> where <i>J</i> has <i>qualName</i>.
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">name ::= ("this" | ID) ["/" ID]*
ref ::= name | "univ" | "Int" | "seq/Int"  
</pre>
</div>

<p>
Note: the definition of name given above introduces ambiguities
because any reserved word (e.g. "and" or "else") also parses as an
<i>ID</i> and thus as a <i>name</i>.  A possible solution to the ensuing
problems (a more complicated definition that excludes the
reserved words) is given <a href="#names-minus">below</a>.
</p>

<p>
Note that Jackson specified (p. 260) that "A numeric constant consists
of a sequence of digits between 0 and 9, whose first digit is not zero."
But the Analyzer accepts "<code>0</code>" as a numeric constant (e.g. in
<code>/examples/algorithms/stable_ringlead.als</code>).  So the definition of
<i>number</i> above has been modified to include "0".
</p>
</div>
</div>

<div id="outline-container-orgeb17bd9" class="outline-3">
<h3 id="orgeb17bd9"><span class="section-number-3">8.2.</span> Multiplicities and quantifiers</h3>
<div class="outline-text-3" id="text-8-2">
<div class="org-src-container">
<pre class="src src-ixml">quant: "all" | "no" | -mult | "sum".
mult: "some" | "lone" | "one".
</pre>
</div>

<p>
<i>J</i> defines both <i>mult</i> and <i>quant</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">mult ::= "lone" | "some" | "one"
</pre>
</div>
<div class="org-src-container">
<pre class="src src-Jebnf">quant ::= "all" | "no" | "sum" | mult
</pre>
</div>

<p>
<i>G</i> has no <i>mult</i> production.
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">quant ::= "all" | "no" | "some" | "lone" | "one" | "sum"
</pre>
</div>
</div>
</div>


<div id="outline-container-ops" class="outline-3">
<h3 id="ops"><span class="section-number-3">8.3.</span> Operators</h3>
<div class="outline-text-3" id="text-ops">
<p>
In the ixml grammar, these productions are unreachable (I hope)
and are here only for the moment.
</p>

<div class="org-src-container">
<pre class="src src-ixml">binOp: "||" | "or" | "&amp;&amp;" | "and" | "&amp;" | "&lt;=&gt;" | "iff"
        | "=&gt;" | "implies" | "+" | "-" | "++" | "&lt;:" | ":&gt;" | "." | "&lt;&lt;" | "&gt;&gt;" | "&gt;&gt;&gt;".

arrowOp: ("some"|"one"|"lone"|"set")?, "-&gt;", ("some"|"one"|"lone"|"set")?.

compareOp: "=" | "in" | "&lt;" | "&gt;" | "=&lt;" | "&gt;=".

unOp: "!" | "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | "#" | "~" | "*" | "^".
</pre>
</div>

<p>
In order to get more informative nonterminal names, we have
embedded each operator into a distinctive production.  Both <i>J</i>
and <i>G</i>, however, make the grammar briefer by handling operators
generically.
</p>
</div>

<div id="outline-container-orgf7322dc" class="outline-4">
<h4 id="orgf7322dc"><span class="section-number-4">8.3.1.</span> Unary operators</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
<i>J</i> has:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">unOp ::= "!" | "not" | "no" | mult | "set" | "#" | "~" | "*" | "^"
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">unOp ::= "!" | "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | "#" | "~" | "*" | "^"
</pre>
</div>
</div>
</div>

<div id="outline-container-org0356621" class="outline-4">
<h4 id="org0356621"><span class="section-number-4">8.3.2.</span> Binary operators</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
Both <i>J</i> and <i>G</i> distinguish arrow operators and comparison operators
from other binary operators.
</p>

<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">binOp ::= "||" | "or" | "&amp;&amp;" | "and" | "&lt;=&gt;" | "iff" | "=&gt;" | "implies" |
   | "&amp;" | "+" | "-" | "++" | "&lt;:" | ":&gt;" | "." 

arrowOp ::= [mult|"set"] "-&gt;" [mult|"set"]

compareOp ::= "in" | "=" | "&lt;" | "&gt;" | "=&lt;" | "&gt;="
</pre>
</div>

<p>
<i>G</i>:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">binOp ::= "||" | "or" | "&amp;&amp;" | "and" | "&amp;" | "&lt;=&gt;" | "iff"
        | "=&gt;" | "implies" | "+" | "-" | "++" | "&lt;:" | ":&gt;" | "." | "&lt;&lt;" | "&gt;&gt;" | "&gt;&gt;&gt;"

arrowOp ::= ["some"|"one"|"lone"|"set"] "-&gt;" ["some"|"one"|"lone"|"set"]

compareOp ::= "=" | "in" | "&lt;" | "&gt;" | "=&lt;" | "&gt;="
</pre>
</div>
</div>
</div>


<div id="outline-container-orgb69fee5" class="outline-4">
<h4 id="orgb69fee5"><span class="section-number-4">8.3.3.</span> Precedence</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
<i>G</i> starts with a list of operator precedence values (low to high):
</p>

<ol class="org-ol">
<li>let    all a:X|F   no a:X|F   some a:X|F   lone a:X|F   one a:x|F   sum a:x|F</li>
<li>||</li>
<li>&lt;=&gt;</li>
<li>=&gt;     =&gt; else</li>
<li>&amp;&amp;</li>
<li>!</li>
<li>in     =        &lt;        &gt;       &lt;=      &gt;=      !in   !=   !&lt;   !&gt;  !&lt;=  !&gt;=</li>
<li>no X   some X   lone X   one X   set X   seq X</li>
<li>&lt;&lt;     &gt;&gt;       &gt;&gt;&gt;</li>
<li>+      -</li>
<li>#X</li>
<li>++</li>
<li>&amp;</li>
<li>-&gt;</li>
<li>&lt;:</li>
<li>:&gt;</li>
<li>[]</li>
<li>.</li>
<li>~    *     ^</li>
</ol>

<p>
All binary operators are left-associative, except the arrow operators (<code>-&gt;</code>),
the implication (<code>a=&gt;b</code>), and if-then-else (<code>a=&gt;b else c</code>).
</p>
</div>
</div>
</div>


<div id="outline-container-org2e89bb1" class="outline-3">
<h3 id="org2e89bb1"><span class="section-number-3">8.4.</span> Constants</h3>
<div class="outline-text-3" id="text-8-4">
<p>
<i>J</i>:
</p>
<div class="org-src-container">
<pre class="src src-Jebnf">const ::= ["-"] number | "none" | "univ" | "iden"
</pre>
</div>

<p>
In <i>G</i>, constants are not separately identified.
</p>
</div>
</div>

<div id="outline-container-orga37b31e" class="outline-3">
<h3 id="orga37b31e"><span class="section-number-3">8.5.</span> Separators</h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-ixml">-comma: s, -",", s.
slash: s, -"/", s.
plus:  s, -"+", s.
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c04827" class="outline-3">
<h3 id="org4c04827"><span class="section-number-3">8.6.</span> Whitespace</h3>
<div class="outline-text-3" id="text-8-6">
<div class="org-src-container">
<pre class="src src-ixml">-S = (ws_char | comment)+.
-s = S?.

-ws_char: -[#20; #9; #A; #D]. 
{ ws_char: SP; TAB; LF; CR.
SP: #20.
TAB: #9.
LF: #A.
CR: #D. }
</pre>
</div>
</div>
</div>

<div id="outline-container-orge62aedc" class="outline-3">
<h3 id="orge62aedc"><span class="section-number-3">8.7.</span> Comments</h3>
<div class="outline-text-3" id="text-8-7">
<p>
There are two kinds of comments: from "//" or "&#x2013;" to the end of the
line, and from "<code>/*</code>" to "<code>*/</code>".  The one-liners are fairly
straightforward.  We distinguish them in order to specify that
following the set-difference operator "-" no double-hyphen comment may
immediately follow.  (The example on page 300 of <i>SA</i> is otherwise
ambiguous because of the comment reading "<code>------------- bug! (see
page 306)</code>".)
</p>

<div class="org-src-container">
<pre class="src src-ixml">comment:  double-slash; double-hyphen; slash-star.
-double-slash:  -"//", ~[#A; #D]*, NL.
-double-hyphen: -"--", ~[#A; #D]*, NL.
-NL: -#D?, -#A.
careful-ws: ((ws_char; double-slash; slash-star), s)?.
</pre>
</div>

<p>
Slash-star comments don't nest and <i>slash-star</i> thus defines a regular
language.  For reasons which may be pragmatic or merely quixotic, I'd
like to define the non-terminal with a single production rule with a
regular expression on the right-hand side.  But experience shows that
getting the regular expression correct can be tricky.  (Put it this
way: it took the XML working group at least two weeks to get the
definition of XML comments correct.  And we did so by abandoning
conventional regular-expression syntax and introducing the
set-difference operator.)
</p>

<p>
But it is not hard to describe the desired language with a
finite state automaton which is simple enough to inspire some
confidence:
</p>


<div id="org3fac698" class="figure">
<p><img src="images/slash-star.dot.png" alt="slash-star.dot.png" />
</p>
</div>

<p>
This, in turn, can be translated readily into a regular grammar:
</p>

<div class="org-src-container">
<pre class="src src-ixml">      slash-star: -"/*", looking-for-star.
looking-for-star: ~["*"], looking-for-star
                | "*", found-star.
      found-star: "/", end-comment
                | "*", found-star
                | ~["/"; "*"], looking-for-star.
     end-comment: {}.
</pre>
</div>

<p>
From this, we can derive a regular expression by systmatically
modifying the grammar.
</p>

<ol class="org-ol">
<li><p>
Apply Arden's Lemma to <i>looking-for-star</i> to get
</p>
<div class="org-src-container">
<pre class="src src-ixml">looking-for-star: ~["*"]*, "*", found-star.
</pre>
</div></li>

<li><p>
Expand <i>looking-for-star</i> in the last line of <i>found-star</i> to get:
</p>
<div class="org-src-container">
<pre class="src src-ixml">found-star: "/", end-comment
          | "*", found-star
          | ~["/"; "*"], ~["*"]*, "*", found-star.
</pre>
</div></li>

<li><p>
Fold the second and third lines of <i>found-star</i> together to get:
</p>
<div class="org-src-container">
<pre class="src src-ixml">found-star: "/", end-comment
          | ("*" | (~["/"; "*"], ~["*"]*, "*")), found-star.
</pre>
</div></li>

<li><p>
Simplify in the second line of <i>found-star</i> to get:
</p>
<div class="org-src-container">
<pre class="src src-ixml">found-star: "/", end-comment
          | (~["/"; "*"], ~["*"]*)?, "*", found-star.
</pre>
</div></li>

<li><p>
Apply Arden's Lemma to <i>found-star</i>:
</p>
<div class="org-src-container">
<pre class="src src-ixml">found-star: ((~["/"; "*"], ~["*"]*)?, "*")*, "/", end-comment.
</pre>
</div>

<p>
We now have:
</p>
<div class="org-src-container">
<pre class="src src-ixml">slash-star: -"/*", looking-for-star.
looking-for-star: ~["*"]*, "*", found-star.
found-star: ((~["/"; "*"], ~["*"]*)?, "*")*, "/", end-comment.
end-comment: {}.
</pre>
</div></li>

<li><p>
The nonterminals <i>end-comment</i>, <i>found-star</i>, and
<i>looking-for-star</i> can now be expanded in place:
</p>
<div class="org-src-container">
<pre class="src src-ixml">slash-star: -"/*", ~["*"]*, "*", ((~["/"; "*"], ~["*"]*)?, "*")*, "/".
</pre>
</div></li>
</ol>

<p>
This gives us the desired single-rule definition of <i>slash-star</i>.
</p>
<div class="org-src-container">
<pre class="src src-ixml">-slash-star: -"/*", ~["*"]*, "*", ((~["/"; "*"], ~["*"]*)?, "*")*, "/".
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf839529" class="outline-3">
<h3 id="orgf839529"><span class="section-number-3">8.8.</span> Keywords</h3>
<div class="outline-text-3" id="text-8-8">
<p>
Are these used?  Should they be?
</p>

<div class="org-src-container">
<pre class="src src-ixml">THIS: "this".
PRIVATE:  "private".
UNIV: "univ".
INT: "Int".
SEQINT: "seq/Int".
NONE: "none".
IDEN: "iden".
private: "private".
abstract: "abstract".
EXACTLY: "exactly".
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org41bcde1" class="outline-2">
<h2 id="org41bcde1"><span class="section-number-2">9.</span> Miscellaneous</h2>
<div class="outline-text-2" id="text-9">
<p>
There is some stuff that doesn't have a good home.  Some of it I don't know anything about.
</p>
</div>

<div id="outline-container-org16bbe1a" class="outline-3">
<h3 id="org16bbe1a"><span class="section-number-3">9.1.</span> Enumerations</h3>
<div class="outline-text-3" id="text-9-1">
<p>
Enumerations are not present in <i>J</i> but are added as a new
form of paragraph in <i>G</i>.
</p>

<div class="org-src-container">
<pre class="src src-ixml">enum-decl: "enum", s, name, s, "{", s, name++comma, s, "}".
</pre>
</div>

<p>
<i>G</i> defines them thus:
</p>
<div class="org-src-container">
<pre class="src src-ebnf4">enumDecl ::= "enum" name "{" name  ("," name)*  "}"
</pre>
</div>
</div>
</div>


<div id="outline-container-names-minus" class="outline-3">
<h3 id="names-minus"><span class="section-number-3">9.2.</span> Avoiding ambiguity between keywords and names</h3>
<div class="outline-text-3" id="text-names-minus">
<p>
Defining <i>name</i> and <i>ID</i> as done <a href="#names-nums">above</a> is sub-optimal, because it
means that keywords are all also recognizable as names.  Perhaps we
can derive a suitable grammar by starting from a simple FSA, as was
done for comments.
</p>

<p>
The following keywords are reserved:
abstract, all, and, as, assert,
but,
check,
disj,
else, exactly, extends,
fact, for, fun,
iden, iff, implies, in,
Int,
let, lone,
module,
no, none, not,
one, open, or,
pred,
run,
set, sig, some, sum,
univ.
</p>

<p>
For the record (it will matter at some point), the Alloy 6 grammar
also appears to have: enum, expect, int (lowercase), private, seq,
String, this, NAME, NUMBER, STRING, var, always, eventually, after,
before, historically, once, releases, until, since, triggered, steps.
(I say "appears to have" because I'm not finding the CUP file
completely clear.)
</p>

<p>
Alloy 6 may also have the spellings "disjoint" and "&lt;=".  At first
glance I thought it also added the keyword "trace", but I now think
that that was just a gloss on ";", the trace-sequence operator.
</p>

<p>
If we had a set subtraction operator, we could write:
</p>
<div class="org-src-container">
<pre class="src src-ixml">name: ID but-not reserved-word.

reserved-word: "abstract"; "all"; "and"; "as"; "assert"; 
               "but"; 
               "check";
               "disj";
               "else "; "exactly "; "extends";
               "fact "; "for "; "fun"; 
               "iden "; "iff "; "implies "; "in"; 
               "Int"; 
               "let "; "lone"; 
               "module"; 
               "no "; "none "; "not"; 
               "one"; "open"; "or"; 
               "pred"; "
               run"; 
               "set"; "sig"; "some"; "sum"; 
               "univ".
</pre>
</div>

<p>
And similarly, if we had a priority operator, we could say that if
something can be parsed as either a <i>name</i> or as the keyword <code>else</code>,
the latter parse is to be preferred.
</p>

<p>
But we don't have a set subtraction operator, or a priority operator.
Since both <i>name</i> and the list of reserved words are regular, we know
that we can express what we want as a regular language.
</p>

<p>
It should be possible in principle to devise an FSA analogous to the
one given above for slash-star comments, turn it into a grammar, and
then simplify the grammar, either partially or all the way into a
single regular expression.  But given these thirty-five reserved
words, there would be somewhat more than 100 states in the FSA; even
drawing it would be tedious, and manipulating the resulting regular
grammar would be rather error prone.
</p>

<p>
But the principle of the FSA is simple enough to describe: it has a
start state, and depending on the initial letter, the next state
reached is either
</p>

<ul class="org-ul">
<li>a state in which we know that the <i>name</i> we are about to match
is not a keyword; or</li>
<li>a state in which we have matched part of a keyword but not the
entire keyword.</li>
</ul>

<p>
For the first of these, one state suffices.  When we have matched part
of a keyword, the state must depend on which keyword(s) we have
partially matched, and how much of them.  One state for each prefix of
each keyword. But I won't go into more detail.
</p>

<p>
For now, I will abandon thought of a regular expression and settle for
a comprehensible grammatical expression.
</p>

<p>
One form that is simple to understand is a rule with a flat set of
right-hand sides, one for each string which is a prefix (proper or
improper) of any reserved word.
</p>

<p>
For any such prefix <i>p</i>, one of three cases applies:
</p>

<ul class="org-ul">
<li><p>
<i>p</i> is itself a reserved word (and not a prefix of any other
reserved word).  E.g. "<code>assert</code>".
</p>

<p>
We must require more characters, so the expression we
want is "<code>'assert', namechar+</code>".
</p></li>

<li><p>
<i>p</i> is both a proper prefix of some reserved word <i>r</i> and
is itself a reserved word. E.g. "<code>as</code>".
</p>

<p>
We must require more characters, and ensure that the characters
added distinguish the string from <i>r</i>.  The easiest way is to
require that it differ from <i>r</i> in the next character.
"<code>'as', nc-not-s, namechar*</code>".
</p></li>

<li><p>
<i>p</i> is a proper prefix of some reserved word <i>r</i> and
not itself a reserved word <i>t</i>.  E.g. "<code>asse</code>".
</p>

<p>
We must accept <i>p</i> as a name, and ensure that any name
beginning with <i>p</i> differs from <i>r</i> in the next character
after <i>p</i>.  So:  "<code>'asse', (nc-not-r, namechar*)?</code>".
</p></li>
</ul>

<p>
Note the structural similarity between the second and third cases;
they differ only in that one requires a non-empty suffix to <i>p</i> (so as
to ensure that <i>p</i> itself is not accepted as a name), and the other
makes the suffix optional (because <i>p</i> should be accepted as a name).
</p>

<p>
It will be convenient to have nonterminals meaning "any name character"
and "any name character except <i>x</i>" for some character <i>x</i>.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ name characters:  possible continuations for a name }
-namechar: ["a"-"z";          "A"-"Z"; "0"-"9"; "_"; #27; #22].

{ The set of name characters, minus individual characters }
-nc-not-a: [         "b"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-b: ["a";     "c"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-c: ["a"-"b"; "d"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-d: ["a"-"c"; "e"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-e: ["a"-"d"; "f"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-f: ["a"-"e"; "g"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-g: ["a"-"f"; "h"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-h: ["a"-"g"; "i"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-i: ["a"-"h"; "j"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-j: ["a"-"i"; "k"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-k: ["a"-"j"; "l"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-l: ["a"-"k"; "m"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-m: ["a"-"l"; "n"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-n: ["a"-"m"; "o"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-o: ["a"-"n"; "p"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-p: ["a"-"o"; "q"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-r: ["a"-"q"; "s"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-s: ["a"-"r"; "t"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-t: ["a"-"s"; "u"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-u: ["a"-"t"; "v"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-v: ["a"-"u"; "w"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-x: ["a"-"w"; "y"-"z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-y: ["a"-"x";     "z"; "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-I: ["a"-"z"; "A"-"H"; "J"-"Z"; "0"-"9"; "_"; #27; #22].
</pre>
</div>

<p>
It turns out that some times we want to exclude more than one name
character from the set.  After we have read an "a", for example, we
must be careful about the letters "b" (as in "<code>abstract</code>"), "l" (as in
"<code>all</code>"), "n" ("<code>and</code>'), and "s" ("<code>as</code>", "<code>assert</code>").
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ Some doubles and triples }
-nc-not-aou: ["b"-"n"; "p"-"t"; "v"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-at: ["b"-"s"; "u"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-blns: ["a"; "c"-"k"; "m"; "o"-"r"; "t"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-dfmn: ["a"-"c"; "e"; "g"-"l"; "o"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-eiou: ["a"-"d"; "f"-"h"; "j"-"n"; "p"-"t"; "v"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-eo: ["a"-"d"; "f"-"n"; "p"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-lx: ["a"-"k"; "m"-"w"; "y"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-npr: ["a"-"m"; "o"; "q"; "s"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-nt: ["a"-"m"; "o"-"s"; "u"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
-nc-not-qt: ["a"-"p"; "r"-"s"; "u"-"z";
             "A"-"Z"; "0"-"9"; "_"; #27; #22].
</pre>
</div>

<p>
We also want a nonterminal defining the set of letters (possible
name-initial characters) which do not begin any keyword.
</p>

<div class="org-src-container">
<pre class="src src-ixml">letter-no-abcdefiIlmnoprstu: ["ghjkqvwxyz"; "A"-"H"; "J"-"Z"].
</pre>
</div>

<p>
And now we can define the nonterminal we want:
</p>

<div class="org-src-container">
<pre class="src src-ixml">-name-minus-reserved-words = 
  -letter-no-abcdefiIlmnoprstu, namechar*;

  'a', (nc-not-blns, namechar*)? ; 
  'ab', (nc-not-s, namechar*)? ; 
  'abs', (nc-not-t, namechar*)? ; 
  'abst', (nc-not-r, namechar*)? ; 
  'abstr', (nc-not-a, namechar*)? ; 
  'abstra', (nc-not-c, namechar*)? ; 
  'abstrac', (nc-not-t, namechar*)? ; 
  'abstract', namechar+ ; 
  'al', (nc-not-l, namechar*)? ; 
  'all', namechar+ ; 
  'an', (nc-not-d, namechar*)? ; 
  'and', namechar+ ; 
  'as', nc-not-s, namechar* ; 
  'ass', (nc-not-e, namechar*)? ; 
  'asse', (nc-not-r, namechar*)? ; 
  'asser', (nc-not-t, namechar*)? ; 
  'assert', namechar+ ; 
  'b', (nc-not-u, namechar*)? ; 
  'bu', (nc-not-t, namechar*)? ; 
  'but', namechar+ ; 
  'c', (nc-not-h, namechar*)? ; 
  'ch', (nc-not-e, namechar*)? ; 
  'che', (nc-not-c, namechar*)? ; 
  'chec', (nc-not-k, namechar*)? ; 
  'check', namechar+ ; 
  'd', (nc-not-i, namechar*)? ; 
  'di', (nc-not-s, namechar*)? ; 
  'dis', (nc-not-j, namechar*)? ; 
  'disj', namechar+ ; 
  'e', (nc-not-lx, namechar*)? ; 
  'el', (nc-not-s, namechar*)? ; 
  'els', (nc-not-e, namechar*)? ; 
  'else', namechar+ ; 
  'ex', (nc-not-at, namechar*)? ; 
  'exa', (nc-not-c, namechar*)? ; 
  'exac', (nc-not-t, namechar*)? ; 
  'exact', (nc-not-l, namechar*)? ; 
  'exactl', (nc-not-y, namechar*)? ; 
  'exactly', namechar+ ; 
  'ext', (nc-not-e, namechar*)? ; 
  'exte', (nc-not-n, namechar*)? ; 
  'exten', (nc-not-d, namechar*)? ; 
  'extend', (nc-not-s, namechar*)? ; 
  'extends', namechar+ ; 
  'f', (nc-not-aou, namechar*)? ; 
  'fa', (nc-not-c, namechar*)? ; 
  'fac', (nc-not-t, namechar*)? ; 
  'fact', namechar+ ; 
  'fo', (nc-not-r, namechar*)? ; 
  'for', namechar+ ; 
  'fu', (nc-not-n, namechar*)? ; 
  'fun', namechar+ ; 
  'i', (nc-not-dfmn, namechar*)? ; 
  'id', (nc-not-e, namechar*)? ; 
  'ide', (nc-not-n, namechar*)? ; 
  'iden', namechar+ ; 
  'if', (nc-not-f, namechar*)? ; 
  'iff', namechar+ ; 
  'im', (nc-not-p, namechar*)? ; 
  'imp', (nc-not-l, namechar*)? ; 
  'impl', (nc-not-i, namechar*)? ; 
  'impli', (nc-not-e, namechar*)? ; 
  'implie', (nc-not-s, namechar*)? ; 
  'implies', namechar+ ; 
  'in', nc-not-t, namechar* ; 
  'int', namechar+ ; 
  'I', (nc-not-n, namechar*)? ; 
  'In', (nc-not-t, namechar*)? ; 
  'Int', namechar+ ; 
  'l', (nc-not-eo, namechar*)? ; 
  'le', (nc-not-t, namechar*)? ; 
  'let', namechar+ ; 
  'lo', (nc-not-n, namechar*)? ; 
  'lon', (nc-not-e, namechar*)? ; 
  'lone', namechar+ ; 
  'm', (nc-not-o, namechar*)? ; 
  'mo', (nc-not-d, namechar*)? ; 
  'mod', (nc-not-u, namechar*)? ; 
  'modu', (nc-not-l, namechar*)? ; 
  'modul', (nc-not-e, namechar*)? ; 
  'module', namechar+ ; 
  'n', (nc-not-o, namechar*)? ; 
  'no', nc-not-nt, namechar* ; 
  'non', (nc-not-e, namechar*)? ; 
  'none', namechar+ ; 
  'not', namechar+ ; 
  'o', (nc-not-npr, namechar*)? ; 
  'on', (nc-not-e, namechar*)? ; 
  'one', namechar+ ; 
  'op', (nc-not-e, namechar*)? ; 
  'ope', (nc-not-n, namechar*)? ; 
  'open', namechar+ ; 
  'or', namechar+ ; 
  'p', (nc-not-r, namechar*)? ; 
  'pr', (nc-not-e, namechar*)? ; 
  'pre', (nc-not-d, namechar*)? ; 
  'pred', namechar+ ; 
  'r', (nc-not-u, namechar*)? ; 
  'ru', (nc-not-n, namechar*)? ; 
  'run', namechar+ ; 
  's', (nc-not-eiou, namechar*)? ; 
  'se', (nc-not-qt, namechar*)? ; 
  'seq', namechar+ ; 
  'set', namechar+ ; 
  'si', (nc-not-g, namechar*)? ; 
  'sig', namechar+ ; 
  'so', (nc-not-m, namechar*)? ; 
  'som', (nc-not-e, namechar*)? ; 
  'some', namechar+ ; 
  'su', (nc-not-m, namechar*)? ; 
  'sum', namechar+ ;
  't', (nc-not-h, namechar*)? ;
  'th', (nc-not-i, namechar*)? ;
  'thi', (nc-not-s, namechar*)? ;
  'this', namechar+ ;
  'u', (nc-not-n, namechar*)? ; 
  'un', (nc-not-i, namechar*)? ; 
  'uni', (nc-not-v, namechar*)? ; 
  'univ', namechar+ .
</pre>
</div>

<p>
Note that none of the nonterminals used in the production for
<i>name-minus-reserved-words</i> is recursive.  So we can in fact, if we
wish, create a single regular expression by inlining all the
nonterminals (I mean, replacing each reference to <i>namechar</i> with its
definition, and similarly for each of the other nonterminals).
</p>

<p>
Now we can define <i>name</i> as any ID other than a reserved word:
</p>

<div class="org-src-container">
<pre class="src src-ixml">name: -name-minus-reserved-words.          
</pre>
</div>

<p>
Note that there are places where some or all of the predefined names
also need to be included.  
</p>
<ul class="org-ul">
<li>"<code>none</code>"</li>
<li>"<code>univ</code>"</li>
<li>"<code>iden</code>"</li>
<li>"<code>Int</code>"</li>
<li>"<code>int</code>"</li>
</ul>

<p>
In some cases, this is accomplished by using the nonterminal <i>ref</i>
instead of <i>name</i> or <i>OQName</i>, to accept "<code>univ</code>", "<code>Int</code>", and
"<code>seq/Int</code>". In other cases, some or all predefined names are
mentioned explicitly.  In <i>expr20</i> for example all of the above are
included explicitly (except "<code>int</code>", which may need adding); in
scopes, "<code>Int</code>" and "<code>seq/Int</code>" are handled specially.
</p>

<p>
The definition of name qualifiers calls out "<code>this</code>" specially;
it's not listed as a reserved word, but as far as I can tell
it functions as one.
</p>

<p>
An alternative approach would be to define them all as names; I tried
this, in the form shown below, but it did not work very well.
</p>
<div class="org-src-container">
<pre class="src src-ixml">name: -name-minus-reserved-words
    ; "iden"
    ; "int"
    ; "Int"
    ; "none"
    ; "univ"
    .
</pre>
</div>
</div>
</div>

<div id="outline-container-BOP-POP" class="outline-3">
<h3 id="BOP-POP"><span class="section-number-3">9.3.</span> Operator precedence and interactions of binary and unary operators</h3>
<div class="outline-text-3" id="text-BOP-POP">
<p>
For the most part, the multi-level grammar for expressions given <a href="#expressions">above</a>
accepts the same language as the Alloy Analyzer and produces the same
(or acceptably similar) parse trees.  But there are exceptions which
arise from the interaction of binary infix operators and unary prefix
(or suffix) operators.
</p>

<p>
When an operator-precedence table is used (as in the definition of
Alloy) to specify the binding strengths of operators, there appear to
be two ways to interpret the ordering.  One is to say that in any
abstract syntax tree produced from unparenthesized input, parent/child
relations will hold between operators of different binding strengths
only when the parent binds less tightly than the child. Thus in a
language with two left-associative binary operators Bop and BOP, in
which BOP binds tighter than Bop, the input
</p>
<pre class="example" id="orgd29204f">
a Bop b BOP c
</pre>
<p>
will be parsed as a Bop expression whose left-hand operand is <i>a</i> and
whose right-hand argument is a BOP.  To use the notation of Prolog
structures: Bop(a, BOP(b, c)). Since BOP is left-associative, then the
input
</p>
<pre class="example" id="orgd5064bb">
a BOP b BOP c
</pre>
<p>
will produce BOP(BOP(a, b), c).
</p>

<p>
Another way to interpret the precedence table is to say that when the
sentence would otherwise be ambiguous, the precedence table shows
which parse tree to prefer.  On the examples just given, it produces
the same results.  When an operand (in these examples, <i>b</i>) has an
operator on each side, the precedence table shows which operator
governs it most directly.
</p>

<p>
The two views differ, however, when the language also has unary
operators (prefix or suffix), an in particular when some unary
operators bind less tightly than some binary operators.
</p>

<p>
If our imaginary language also has a unary prefix operator Pop, which
binds less tightly than Bop or BOP, then both views agree that the
input
</p>
<pre class="example" id="org2d8474c">
Pop a BOP b
</pre>
<p>
will produce Pop(BOP(a, b)).  But what about the input
</p>
<pre class="example" id="orga9f3312">
a BOP Pop b
</pre>
<p>
in which the prefix operator and the binary operator are adjacent?
</p>

<p>
On the first view, there is an operator priority clash: BOP and Pop
both might govern operand <i>b</i>, and Pop is closer, but BOP binds more
tightly. Parsing this input as BOP(a, Pop(b)) would violate the rule
that unparenthesized input never produces a syntax tree with a
loose-binding operator (Pop) as a child of a tight-binding operator
(BOP).  This is the behavior of the operator-precedence parser built
into Prolog systems.
</p>

<p>
On the second view, the relative priority of the operators is not
relevant to the case.  There is only one candidate tree, and no need
to consult the precedence table in order to decide which tree to
accept.  This is the behavior observable in parsers built using yacc
and similar tools built to work like yacc.  Concretely, those parsers
use the precedence table to resolve shift/reduce conflicts.  Since
there is no shift-reduce conflict in the input "a BOP Pop b", the
positions of BOP and Pop in the precedence table are immaterial.
</p>

<p>
Concretely, Alloy accepts without demur an expression like <i>p and some
x : Doc | q[x]</i>, with an unparenthesized level-1 quantified formula as
the right operand of a level-5 conjunction.
</p>

<p>
We could attempt to model this behavior by making the right-hand side
of any binary operator allow expressions rooted in prefix unary
operators (let, all, some, &#x2026; in level 1; negation at level 6;
quantified expressions at level 8; cardinality (#) at level 11) even
if they bind less tightly.
</p>

<p>
But this change to the grammar has the unfortunate side effect that an
input of the form
</p>
<pre class="example" id="orge2cd533">
a BOP Pop b BOP c
</pre>
<p>
is ambiguous between BOP(a, Pop(BOP(b, c))) and BOP(BOP(a, Pop(b)),
c).  Yacc-style parsers (and the Analyzer) will prefer the former.  An
ixml processor will simply choose one and inform the user that there
were others.
</p>

<p>
Similar considerations apply in the case of the suffix operator
box-join.  The Alloy Analyzer accepts the input "a.b[c].d", which a
strictly leveled grammar would reject.  (Such expressions do occur in
the sample models, so I would like to accept them if possible.)  For
reasons I am not sure I understand, allowing the left-hand side of the
dot-join operator to include box joins does not seem to lead to
adverse consequences.  It may possibly introduce an ambiguity; if so,
the ambiguity may be harmless.
</p>

<p>
Further investigation is needed.
</p>
</div>
</div>

<div id="outline-container-org72dcb6d" class="outline-3">
<h3 id="org72dcb6d"><span class="section-number-3">9.4.</span> Testing</h3>
<div class="outline-text-3" id="text-9-4">
<p>
There is not currently a systematic test suite for this grammar; one
could be constructed by
</p>
<ul class="org-ul">
<li>generating test cases from the grammar in the usual way, and</li>
<li>running those tests against the Alloy Analyzer to establish a
baseline set of results, then</li>
<li>running those tests against the grammar given here.</li>
</ul>

<p>
In the meantime, a less thorough but useful set of test cases is given
by the set of Alloy models distributed with the Alloy Analyzer.  These
include models given in Jackson's book, a directory of examples, and a
directory of utility models.  All are intended as acceptable models, so
running them as a test set just involves parsing them all and checking
the results for <i>ixml:state</i> attributes identifying problems.
</p>

<p>
As of noon, 25 March 2024, the models distributed with Alloy 6
produced the results shown below.  (As of the next day some of the
unexpected discrepancies have been fixed, others not.)
</p>
</div>

<div id="outline-container-orga1e7e0d" class="outline-4">
<h4 id="orga1e7e0d"><span class="section-number-4">9.4.1.</span> Expected discrepancies</h4>
<div class="outline-text-4" id="text-9-4-1">
<p>
Because of the discrepances between the language accepted by this
grammar and that accepted by the Alloy Analyzer which were discussed
at the beginning of this document, some discrepant results are
expected.
</p>

<p>
Some illustrate the issue with unparenthesized quantification in
operands of tighter-binding operators:
</p>

<ul class="org-ul">
<li><code>book/chapter6/hotel4.als</code> fails to parse (unparenthesized quantified
formula within disjunction).</li>
<li><code>book/chapter6/mediaAssets.als</code> fails to parse (unparenthesized
<i>let</i>-expression within conditional).</li>
<li><code>book/chapter6/ringElection2.als</code> fails to parse (unparenthesized
quantified formula within conditional).</li>
</ul>

<p>
For example, model <code>book/chapter6/hotel4.als</code> contains the following fact:
</p>
<pre class="example" id="org1d9de82">
fact NoIntervening {
	all c: Checkin |
		c.post = last
		or some e: Entry {
			e.pre = c.post
			e.room = c.room
			e.guest = c.guest
		}
	}
</pre>
<p>
Under the grammar given here, this requires parentheses around the
quantified formula over <i>e</i>: "<code>some e: ... c.guest</code>".
</p>

<p>
In <code>book/chapter6/mediaAssets.als</code> the issue is a <i>let</i>-expression
in the consequent-clause of a conditional.
</p>
<pre class="example" id="orgd30b1df">
assert PasteNotAffectHidden {
	all xs, xs": ApplicationState |
		(appInv [xs] and paste [xs, xs"]) =&gt; 
			let c = xs.currentCatalog | xs".catalogState[c].hidden = xs.catalogState[c].hidden
	}
</pre>
<p>
The others listed are similar.
</p>

<p>
Some reflect the grammar's current restriction to Alloy 4, which
does not have keywords or syntax for temporal logic:
</p>
<ul class="org-ul">
<li><code>examples/temporal/buffer.als</code> fails to parse (unrecognized <code>var</code> keyword).</li>
<li><code>examples/temporal/leader.als</code> fails to parse (unrecognized <code>var</code> keyword).</li>
<li><code>examples/temporal/leader_events.als</code> fails to parse (unrecognized <code>var</code> keyword).</li>
<li><code>examples/temporal/trash.als</code> fails to parse (unrecognized <code>var</code> keyword).</li>
</ul>

<p>
Currently, these all fail on an unrecognized <code>var</code> keyword.  Model
<code>examples/temporal/trash.als</code>, for example fails on line 1:
</p>
<pre class="example" id="org4897d34">
var sig File {}
</pre>

<p>
Two cases may reflect either an undocumented extension to the grammar, or
perhaps a relic of earlier syntactic rules.
</p>

<ul class="org-ul">
<li><p>
<code>util/integer.als</code> failed to parse.  The string "<code>fun/add</code>" and
similar are apparently taken as qualified names, but "fun" is a
reserved word, so the grammar does not accept them.
</p>

<p>
Perhaps the prefix "<code>fun/</code>" is a signal to the Analyzer to call a
built-in function implemented in the underlying Java?  The parse
trees shown by the 6.0 Analyzer seem to make this plausible.  For
the declaration "<code>fun plus [n1, n2: Int] : Int { n1 fun/add n2 }</code>",
the parse tree shows a function body whose structure is:
</p>
<ul class="org-ul">
<li>body (Int)
<ul class="org-ul">
<li>int-&gt;int (Int)
<ul class="org-ul">
<li>@+ (Int)
<ul class="org-ul">
<li>int-&gt;int (Int)
<ul class="org-ul">
<li>variable n1 (Int)</li>
</ul></li>
<li>int-&gt;int (Int)
<ul class="org-ul">
<li>variable n2 (Int)</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Since the construction "<code>fun</code>" + "<code>/</code>" + <i>name</i> does not occur in
any other model seen so far, it seems unlikely to be allowed in
user-written models, so I don't now plan to change the gramar to
accept it.
</p></li>

<li><code>util/ordering.als</code> failed to parse.  (Tripped over "<code>module
  util/ordering[exactly elem]</code>" at "<code>elem</code>".  Added "exactly"
to the rule for module declarations.  Now fails on a field name
given as "pred/totalOrder".)</li>
</ul>

<p>
Two cases involve what appear to be casts to "<code>int</code>".  Casts are not
present in the grammar at the moment, because they are not present in
<i>J</i> or <i>G</i>, from which the grammar was derived.  (It looks like they
are present in <i>C</i>, but I don't find the grammatical rules of <i>C</i> easy
to read.
</p>

<ul class="org-ul">
<li><p>
<code>examples/algorithms/stable_ringlead.als</code> fails to parse.  There is
a conditional within the argument of box join.  That establishes
pretty well that it was an error to restrict the argument to
<i>expr10</i>.  Have changed to allow <i>if-then-else</i> as well.
</p>

<p>
Further parsing errors on expressions like "<code>int x = int y</code>".
The quick guide to Alloy 4 says casting expressions must use
brackets, so "<code>int[x] = int[y]</code>" and suggests implicitly that
"<code>int x</code>" is Alloy 3 syntax.  That moves this to a won't-fix.
</p></li>

<li><code>util/sequniv.als</code> failed to parse ("0" as numeric constant).
Fixed.  Now fails on a call to "<code>int[i"]</code>", which the grammar
currently does not accept because "int" is reserved.  To allow
casting expressions of this kind, the grammar would need to
add a rule for them.</li>
</ul>

<p>
One case involves macros &#x2013; a feature described in the documentation
but not in the grammars I'm working from.
</p>

<ul class="org-ul">
<li><code>util/time.als</code> fails to parse because the module uses macros,
which are not currently part of the grammar.</li>
</ul>

<p>
Temporal keywords, casts, and macros all appear to be part of the
Alloy language and it would be nice to support them, if this grammar
were ever to be used to build general purpose Alloy tools.  But the
MLCD models don't use them, and sufficient unto the day is the evil
thereof.
</p>
</div>
</div>

<div id="outline-container-orga48c7c4" class="outline-4">
<h4 id="orga48c7c4"><span class="section-number-4">9.4.2.</span> Unexpected discrepancies (to be fixed)</h4>
<div class="outline-text-4" id="text-9-4-2">
<p>
This category initially had a number of members, but some of the
reasons for failure to parse or ambiguity have now been cleared up.
Others have now been classified for the moment as won't-fix
discrepancies.
</p>
</div>
</div>

<div id="outline-container-org4533c45" class="outline-4">
<h4 id="org4533c45"><span class="section-number-4">9.4.3.</span> Unexpected discrepancies now fixed</h4>
<div class="outline-text-4" id="text-9-4-3">
<p>
Others have now have been fixed.
</p>

<ul class="org-ul">
<li><code>examples/case_studies/com.als</code> is ambiguous.  The ambiguity appears
to be in the definition of <i>name-minus-reserved-words</i>, between two
different right-hand sides, namely "<code>'in', namechar+</code>" and "<code>'int',
  namechar+</code>".  I inserted the second by hand to exclude "<code>int</code>" from
the definition of the nonterminal and failed to change the first.</li>
<li><code>examples/puzzles/handshake.als</code> was ambiguous.  Also <i>int</i>-related.</li>
<li><code>examples/systems/views.als</code> was ambiguous; the ambiguity involved
the keyword "<code>this</code>".  Fixed by adding "<code>this</code>" to the list of non-name
tokens.</li>
<li><code>util/seqrel.als</code> is ambiguous (rule for <i>import</i> allowed trailing
whitespace; now fixed).</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-02-23/2024-03/13</p>
<p class="author">Author: Michael Sperberg-McQueen</p>
<p class="date">Created: 2024-03-26 Tue 16:22</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
